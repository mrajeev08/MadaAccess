---
title: "Draft of Figures for Access Paper"
author: "Malavika Rajeev"
date: "12/19/2018"
output: 
  html_document: default
---

```{r setup, echo = FALSE, message = FALSE, warning = FALSE, results = 'hide'}
rm(list = ls())
library(knitr)
library(RImagePalette)
library(jpeg)
library(tidyverse)
library(lubridate)
library(magrittr)
library(rgdal)
library(broom)
select <- dplyr::select
knitr::opts_chunk$set(fig.pos = 'h', echo = FALSE, message = FALSE, warning = FALSE, results = 'hide')
```

## Goals of this analysis
- To estimate burden of rabies in Madagascar using nationally available bite patient data 
- To explore the potential impacts of expanded access to PEP in Madagascar

## Slide with R Output
## Data
- Patient data from 19 ARMC accross the country over four years (2013 - 2017)
  - includes dates and home locations (to the district level) of patient reporting for PEP
- Patient data from Moramanga ARMC over 28 months (Sep 2016 - Dec 2018)
  - includes dates and home locations (to the commune level) of patients reporting for PEP
  - also includes rabies exposure status based on a combination of clinic-based triage and contact
  tracing (Rajeev et al. 2018)
- Travel times estimated from the Malaria Atlas Project's global friction surface for 2015
- Human population estimates were taken from the 2015 UN adjusted population projections from World Pop

```{r data}
## read in data
ctar_data <- read.csv("data/SaisieRage_DATA_2018-09-21_1755.csv")
ctar_metadata <- read.csv("data/ctar_metadata.csv")
mada_district <- readOGR("data/MadaGIS/MadaPops.shp")
mada_communes <- readOGR("output/communes/communes_extracted.shp")

## catchment data
dist_catchments <- read.csv("output/catchments_district_unmasked.csv", row.names = 1)
names(dist_catchments) <- c("mdg_dis_co", "CTAR", "ttimes_weighted")
comm_catchments <- read.csv("output/catchments_commune_unmasked.csv", row.names = 1)
names(comm_catchments) <- c("mdg_cm_", "CTAR", "ttimes_weighted")

## Centers with no data
no_data <- c("IPM", "Fianarantsoa", "Ambatomainty", "Ambovombe Androy",
             "Antsiranana", "Mandritsara", "Marolambo", "Nosy be", "Sainte Marie",
             "Taolagnaro", "Tsiroanomandidy", "Vangaindrano")
ctar_metadata$exclude <- 0
ctar_metadata$exclude[ctar_metadata$CTAR %in% no_data] <- 1

## Getting ctar district and commune
ctar_metadata$ctar_dist <- mada_district$mdg_dis_co[match(ctar_metadata$District, 
                                                           mada_district$district)]
pts <- SpatialPoints(cbind(ctar_metadata$LONGITUDE, ctar_metadata$LATITUDE), 
                   proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
ctar_metadata$ctar_comm <- over(pts, mada_communes)$mdg_cm_
dist_catchments$ctar_in_dist <- ifelse(dist_catchments$mdg_dis_co %in% ctar_metadata$ctar_dist, 1, 0)
comm_catchments$ctar_in_comm <- ifelse(comm_catchments$mdg_cm_ %in% ctar_metadata$ctar_comm, 1, 0)

```

```{r get data}
## read in data
ctar_data <- read.csv("data/SaisieRage_DATA_2018-09-21_1755.csv")
ctar_metadata <- read.csv("data/ctar_metadata.csv")
mada_district <- readOGR("data/MadaGIS/MadaPops.shp")
mada_communes <- readOGR("output/communes/communes_extracted.shp")

## catchment data
dist_catchments <- read.csv("output/catchments_district_unmasked.csv", row.names = 1)
names(dist_catchments) <- c("mdg_dis_co", "CTAR", "ttimes_weighted")
comm_catchments <- read.csv("output/catchments_commune_unmasked.csv", row.names = 1)
names(comm_catchments) <- c("mdg_cm_", "CTAR", "ttimes_weighted")

## Centers with no data
no_data <- c("IPM", "Fianarantsoa", "Ambatomainty", "Ambovombe Androy",
             "Antsiranana", "Mandritsara", "Marolambo", "Nosy be", "Sainte Marie",
             "Taolagnaro", "Tsiroanomandidy", "Vangaindrano")
ctar_metadata$exclude <- 0
ctar_metadata$exclude[ctar_metadata$CTAR %in% no_data] <- 1

## Getting ctar district and commune
ctar_metadata$ctar_dist <- mada_district$mdg_dis_co[match(ctar_metadata$District, 
                                                           mada_district$district)]
pts <- SpatialPoints(cbind(ctar_metadata$LONGITUDE, ctar_metadata$LATITUDE), 
                   proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
ctar_metadata$ctar_comm <- over(pts, mada_communes)$mdg_cm_
dist_catchments$ctar_in_dist <- ifelse(dist_catchments$mdg_dis_co %in% ctar_metadata$ctar_dist, 1, 0)
comm_catchments$ctar_in_comm <- ifelse(comm_catchments$mdg_cm_ %in% ctar_metadata$ctar_comm, 1, 0)
```

## Summary of analyses: Data
- Cleaning data
  - excluded contacts with suspect cases
  - estimated clinic level underreporting (i.e. incomplete submission of forms)
  - average number of annual bites corrected by clinic level underreporting at the district level
- Travel times
  - calculated weighted mean of travel times by human population summed to the commune level 
  - For each clinic, we defined the catchment area as all communes for which the clinic 
  was the closest ARMC.

## Figure 1: Catchment network and distribution of patient travel

```{r network fig}
## Network fig
## Revise: points = CTAR points with size proportional to number of bites reported, lines to district proportional to the number of bites from that district, outline = by district, communes = polygons shaded by catchments?

## Get color palette from other network fig!
add.alpha <- function(col, alpha=1){
  if(missing(col))
    stop("Please provide a vector of colours.")
  apply(sapply(col, col2rgb)/255, 2, 
                     function(x) 
                       rgb(x[1], x[2], x[3], alpha=alpha))  
}
ctar_metadata$color <- c("#FCC56F","#FFDBE5", "#7A4900", "#CBCDD2", "#0000A6", "#EFF2F1",
                 "#63FFAC", "#B79762", "#004D43", "#8FB0FF", "#997D87", "#FD9C54", "#8362B5",
                 "#578FB0","#5A0007", "#809693", "#D16100", "#1B4400", "#4FC601", "#3B5DFF", 
                 "#4A3B53", "#FF2F80","#61615A", "#BA0900", "#6B7900", "#00C2A0", "#FFAA92",
                 "#FF90C9", "#B903AA", "#FEFFE6", "#E9E9D2")
ctar_metadata$fill <- ctar_metadata$color
ctar_metadata$fill[ctar_metadata$CTAR %in% no_data] <- "#D3D3D3"
ctar_metadata$fill <- add.alpha(ctar_metadata$fill, 0.25)

display_palette(ctar_metadata$color)
dist_catchments %>% left_join(select(ctar_metadata, CTAR, exclude, 
                                     color, fill, ctar_dist, LATITUDE, LONGITUDE)) -> dist_catchments
mada_district@data <- left_join(mada_district@data, dist_catchments)

## get exposure matrix
ctar_data %>% 
  group_by(district, id_ctar) %>% # group by district and ctar
  summarize(n = n()) -> exp_mat # get count of exposures
dist_points <- cbind(select(mada_district@data,
                            mdg_dis_co), coordinates(mada_district))
names(dist_points)[2:3] <- c("dist_long", "dist_lat")
dist_points %>%
 left_join(select(ctar_metadata, ctar_dist, LATITUDE, LONGITUDE), 
           by = c("mdg_dis_co" = "ctar_dist")) %>%
 mutate(dist_long = coalesce(dist_long, LONGITUDE), 
        dist_lat = coalesce(dist_lat, LATITUDE)) -> dist_points

exp_mat %>% 
  left_join(select(dist_points, mdg_dis_co, dist_long, dist_lat), 
            by = c("district" = "mdg_dis_co")) %>%
  left_join(select(ctar_metadata, id_ctar, LATITUDE, LONGITUDE,
                   color, fill, ctar_dist)) -> dist_lines
dist_lines %>% 
  group_by(id_ctar) %>%
  summarise(n = sum(n)) %>%
  left_join(select(ctar_metadata, id_ctar, ctar_dist, LATITUDE, LONGITUDE, color)) -> ctar_points
ctar_points$size <- log(ctar_points$n + 0.1)*0.4
dist_lines$size <- log(dist_lines$n + 0.1)*0.2

ctar_data %>%
  group_by(district) %>%
  summarize(n = n()) %>%
  right_join(select(dist_points, mdg_dis_co, dist_long, dist_lat),
             by = c("district" = "mdg_dis_co")) %>%
  left_join(dist_catchments, by = c("district" = "mdg_dis_co")) -> dist_points
dist_points$size <- log(dist_points$n + 0.1)*0.25

pdf("figs/network.pdf")
plot(mada_district, col = mada_district$fill, border = "grey") 
points(ctar_points$LONGITUDE, ctar_points$LATITUDE, pch = 20, cex = dist_points$size, 
       col = ctar_points$color)
segments(dist_lines$dist_long, dist_lines$dist_lat, x1 = dist_lines$LONGITUDE, y1 = dist_lines$LATITUDE, lwd = dist_lines$size*2, col = dist_lines$color)
dev.off()

exp_mat %>% 
  left_join(select(ctar_metadata, CTAR, id_ctar)) %>%
  left_join(select(dist_catchments, mdg_dis_co, CTAR, exclude), by = c("district" = "mdg_dis_co")) %>%
  filter(exclude == 0) %>%
  group_by(district) %>%
  mutate(prop = n/sum(n),
         catch_match = ifelse(CTAR.x == CTAR.y, 1, 0)) -> catch_check
hist(catch_check$prop[catch_check$catch_match == 1], main = "", xlab = "Proportion patients reporting \n within catchment", col = "grey50", border = "white")

```

## Figure 2: Adjustment for reporting
```{r clinic level reporting}
######### Patient time series
ctar_data %>%
  select(id_ctar, date_de_consultation) %>%
  mutate(date_de_consultation = ymd(date_de_consultation)) %>%
  gather(dose, date_de_consultation, -id_ctar) %>%
  group_by(id_ctar, date_de_consultation) %>%
  summarise(n = n()) -> patient_ts
patient_ts <- patient_ts[!is.na(patient_ts$date_de_consultation), ]
patient_ts$ctar <- ctar_metadata$CTAR[match(patient_ts$id_ctar, ctar_metadata$id_ctar)]
patient_ts <- patient_ts[!is.na(patient_ts$ctar), ]

# ggplot(data = patient_ts, aes(date_de_consultation, ctar)) + 
#   geom_tile(aes(fill = n)) +
#   scale_fill_continuous(type = "viridis", name = "Patients") 

## getting reporting
start_date <- ymd("2014-01-01")
end_date <- ymd("2017-12-31")
ts <- as_tibble(seq(start_date, end_date, by = "day"))

patient_ts %>%
  right_join(ts, by = c("date_de_consultation" = "value")) %>%
  select(id_ctar, date_de_consultation, n) %>%
  spread(id_ctar, n) %>%
  replace(., is.na(.), 0) -> doses_wide
dose_mat <- as.matrix(doses_wide[, 2:(ncol(doses_wide) - 1)])

date_mat <- matrix(NA, nrow(dose_mat), ncol(dose_mat))
for (j in 1:ncol(date_mat)){
  rle(dose_mat[ , j]) %>%
    unclass() %>%
    as.data.frame() %>%
    mutate(end = cumsum(lengths),
         start = c(1, lag(end)[-1] + 1)) %>%
    filter(values == 0, lengths >= 10) -> rles
  for (i in 1:nrow(rles)){
    date_mat[rles$start[i]:rles$end[i], j] <- 0
  }
}

date_mat <- replace(date_mat, is.na(date_mat), 1)
date_mat %>% 
  as_tibble() %>%
  group_by(date = year(doses_wide$date_de_consultation)) %>%
  summarise_all(funs(sum(.)/n())) -> clinic_reporting
colnames(clinic_reporting) <- colnames(doses_wide)[1:(ncol(doses_wide)-1)]
clinic_reporting <- gather(clinic_reporting, id_ctar, prop, -date_de_consultation)
clinic_reporting$ctar <- ctar_metadata$CTAR[match(clinic_reporting$id_ctar, 
                                                  ctar_metadata$id_ctar)]
clinic_reporting$id_ctar <- as.numeric(clinic_reporting$id_ctar)

ggplot(clinic_reporting, aes(x = date_de_consultation, y = ctar, fill = prop)) + 
  geom_tile() +
  scale_fill_gradient(low = "white", high = "blue")
```


```{r district level exposures}
## districts that are non-reporter and data not available yet CTAR
mada_district@data %>%
select(district = mdg_dis_co, pop = pop2015adj, ttimes_weighted, CTAR, exclude) -> covars

to_exclude <- c(grep("contact", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("contam", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("consom", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("passage", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE))
to_exclude <- to_exclude[-grep("date", to_exclude, ignore.case = TRUE)]
ctar_data$excl <- 0
ctar_data$excl[ctar_data$remarque %in% to_exclude] <- 1

ctar_data %>% 
  filter(excl != 1) %>% # exclude contacts
  mutate_at(vars(starts_with("date")), funs(ymd(.))) %>% # format dates
  group_by(year = year(date_de_consultation), district, id_ctar) %>% # group by year and district
  summarize(n = n()) -> exposures # get count of exposures

exposures %>%
  rename(date = year) %>%
  left_join(covars) %>% # add pop + ttimes + reporting
  left_join(clinic_reporting) %>%   # add reporting by clinic + year
  filter(exclude == 0, prop > 0.25) -> exps_cleaned 

exps_cleaned %>%
  group_by(district, date) %>%
  mutate(bites = n/prop) %>%
  summarise(bites = sum(bites, na.rm = TRUE)) %>%
  group_by(district) %>%
  summarise(bites = mean(bites)) %>%
  left_join(covars) -> exps_dist

exps_cleaned %>%
  group_by(ctar, date) %>% ## Need to rename CTAR so clear if it's CTAR in catchment vs. ctar of bites...
  mutate(bites = n/prop) %>%
  summarise(bites = sum(bites, na.rm = TRUE)) %>%
  group_by(ctar) %>%
  summarise(bites = mean(bites)) -> exps_ctar

```


```{r ttimes + pop at commune level}
## Need: weighted ttimes, pop, ctar_in, exclude
comm_catchments %>%
  left_join(select(mada_communes@data, pop = MDG__201, mdg_cm_, district = mtch_ds)) -> comm_covars
comm_covars <- filter(comm_covars, ttimes_weighted != "Inf")
comm_covars %>% 
  left_join(select(mada_district@data, mdg_dis_co, district)) -> comm_data
comm_data$exclude <- dist_catchments$exclude[match(comm_data$mdg_dis_co, dist_catchments$mdg_dis_co)]

## Data to include
nrow(comm_data) - sum(comm_data$exclude)
```

## Summary of analyses: Models of bites as a function of travel time, Moramanga District
- Moramanga models to the commune level:
  $$ mu_{j} = exp(\beta_{t}T_{j} + \beta_{0})\times pop_{j} $$
  $$ mu_{j} $$ = the mean number of bites in commune $j$ 
- We then estimate the likelihood of observing the bites at the commune level at the Moramanga clinic where bites are a poisson distribution around the mean $mu_{j}$

## Summary of analyses: Extending this to the district level
- Moramanga models to the commune level:
  $$ \mu_{d} = \sum \limits_{j=1}^jexp(\beta_{t}T_{j} + \beta_{0})\times pop_{j} $$
  $$  \mu_{d} $$ is the mean number of bites in district which is the sum of bites at the commune level given **commune level travel times** $d$
- We then estimate the likelihood of observing the bites at the district level where bites are a poisson distribution around the mean $mu_{d}$

```{r Moramanga data}
## Libraries
library(ggThemeAssist)
library(colourpicker)
library(dplyr)
library(stringr)
library(lubridate)
library(ISOweek)
library(ggplot2)
library(knitr)
library(prettymapr)
# libraries for gis
library(raster)
library(maptools)
library(maps)
library(GISTools)
library(rgdal)
library(sp)
library(rgdal)
library(gdistance)

source("R/utils.R")

## data from WM
triage <- read.csv("data/moramanga/triage_up_todate.csv", header = TRUE)
ctar <- read.csv("data/moramanga/ctar_up_todate.csv", header = TRUE)
pep <- read.csv (paste0("data/WM/", list.files("data/WM/", pattern = "PEP")), header = TRUE)
hh <- read.csv (paste0("data/WM/", list.files("data/WM/", pattern = "Household")), header = TRUE)
human <- read.csv (paste0("data/WM/", list.files("data/WM/", pattern = "Human")), header = TRUE)
animal <- read.csv (paste0("data/WM/", list.files("data/WM/", pattern = "Animal")), header = TRUE)


## Read in new column names
match.colnames <- function (dataframe, lookup){
  colnames(dataframe) <- lookup$new.colnames[match(colnames(dataframe), 
                                                   lookup$og.colnames)]
  dataframe <- dataframe[ , !names(dataframe) %in% c("NULL")]
  return(dataframe)
}

triage <- match.colnames(triage, subset(col_lookup, form == "triage"))
ctar <- match.colnames(ctar, subset(col_lookup, form == "ctar"))
pep <- match.colnames(pep, subset(col_lookup, form == "pep"))
hh <- match.colnames(hh, subset(col_lookup, form == "hh"))
animal <- match.colnames(animal, subset(col_lookup, form == "animal"))
human <- match.colnames(human, subset(col_lookup, form == "human"))

# fix factor names
match.within <- function (vec_return, mismatch, match){
  for (i in 1:length(match)){
    if (is.na(mismatch[i])) next
    mismatched <- paste0 ("\\<", mismatch[i], "\\>")
    vec_return <- gsub(mismatched, match[i], vec_return, ignore.case = TRUE)
  }
  return (vec_return)
}

## Changing suspected to probable
animal$suspect.animal <- match.within(animal$suspect.animal, "Suspected", "Probable")
human$suspect.exposure <- match.within(human$suspect.exposure, "Suspected", "Probable")
triage$suspect.animal <- match.within(triage$suspect.animal, "Suspected", "Probable")

## get number of animals + humans bitten by biter.IDs here!
animals.bitten.byID <- table(animal$biter.ID)
humans.bitten.byID <- table(human$biter.ID)

## Set-up time series plotting (axes)
tfunc <- function (date, format_date="%Y-%m-%d", start="01-09-2016", format_start="%d-%m-%Y",
                   year1=2016, tstep="month", period=FALSE) {
  get.consec (date, format_date, start, format_start,
              year1, tstep, period) - 8
}

## all dates
triage %>% 
  mutate_at(vars(starts_with("date")), funs(dmy(.))) -> triage
pep$pep.date <- dmy(pep$pep.date)
ctar %>%
  mutate_at(vars(starts_with("date")), funs(dmy(.))) -> ctar
animal %>%
  mutate_at(vars(starts_with("date")), funs(dmy(.))) -> animal
human %>%
  mutate_at(vars(starts_with("date")), funs(dmy(.))) -> human

# triage
triage$commune <- sapply(strsplit(as.character(triage$exposure.location), "\\("), "[", 1)
triage$commune <- trimws(triage$commune, which = "right")
triage$district <- sapply(strsplit(as.character(triage$exposure.location), "\\, "), "[", 2)
triage$district <- gsub(" \\(District\\)", "", triage$district)

# ctar
ctar$commune <- sapply(strsplit(as.character(ctar$patient.location), "\\("), "[", 1)
ctar$commune <- trimws(ctar$commune, which = "right")
ctar$district <- sapply(strsplit(as.character(ctar$patient.location), "\\, "), "[", 2)
ctar$district <- gsub(" \\(District\\)", "", ctar$district)

## animal and human locations
animal <- merge(animal, hh, by = "reference.hh")
human <- merge(human, hh, by = "reference.hh")

## get apprx case dates
ctar$ctar.ID <- paste0(ctar$ctar.ID, "_", year(ctar$date.reported))
human$ctar.ID <- paste0(human$ctar.ID, "_", year(human$date.bitten))
human$reference.ctar <- ctar$reference.ctar[match(human$ctar.ID, ctar$ctar.ID)]
#human$date.bitten[!is.na(human$reference.ctar)] <- ctar$date.bitten[match(human$reference.ctar[!is.na(human$reference.ctar)], ctar$reference.ctar)]

human %>%
  group_by(biter.ID) %>% 
  summarise(sort(date.bitten)[1]) -> date.first.bite
animal$date.case <- date.first.bite$`sort(date.bitten)[1]`[match(animal$ID, date.first.bite$biter.ID)]
animal$date.case[is.na(animal$date.case)] <- animal$date.first.bite[is.na(animal$date.case)]
animal$date.case[is.na(animal$date.case)] <- animal$date.symptoms.started[is.na(animal$date.case)] # fixing animals which don't have a case date (i.e. non-biters, but ones that are still suspect!)
## what about ones without a date?? recheck!

ctar %>%
  group_by(reference.triage) %>% 
  summarise(sort(date.bitten)[1]) -> date.first.bite
triage$date.case <- date.first.bite$`sort(date.bitten)[1]`[match(triage$reference.triage, date.first.bite$reference.triage)]
triage$date.case[is.na(triage$date.case)] <-triage$date.reported[is.na(triage$date.case)]

## get all months 
triage$month <- tfunc(triage$date.reported)
ctar$month <- tfunc(ctar$date.reported)
human$month <- tfunc(human$date.bitten)
animal$month <- tfunc(animal$date.case)
pep$month <- tfunc(pep$pep.date)

## change all true/false to 0/1
triage[triage == FALSE] <- 0
ctar[ctar == FALSE] <- 0
animal[animal == FALSE] <- 0
human[human == FALSE] <- 0
pep[pep == FALSE] <- 0
pep[pep == TRUE] <- 1

## subset to study period (Sep 2016 - to date)
## checks for cases where month is NA!
triage <- subset(triage, month > 0 & month < 25)
ctar <- subset(ctar, month > 0 & month < 25)
human <- subset(human, month > 0 & month < 25)
animal <- subset(animal, month > 0 & month < 25)
pep <- subset(pep, month > 0 & month < 25)

## linking up
ctar$traced <- NA
ctar$traced <- match(ctar$ctar.ID, human$ctar.ID)
ctar$traced[ctar$traced > 0] <- 1
ctar$traced[is.na(ctar$traced)] <- 0
ctar$reference.human <- human$reference.human[match(ctar$ctar.ID, human$ctar.ID)]
triage$reference.human <- ctar$reference.human[match(triage$reference.triage, ctar$reference.triage)] ## here!
triage$suspect.animal[!is.na(triage$reference.human)] <- human$suspect.exposure[match(triage$reference.human[!is.na(triage$reference.human)], human$reference.human)]

ctar$suspect.exposure <- triage$suspect.animal[match(ctar$reference.triage, triage$reference.triage)] ## matched to triage!

nonbites <- c("CTAR_201708_000016", "CTAR_201708_000017", "CTAR_201708_000001", "CTAR_201708_000002",
              "CTAR_201708_000003", "CTAR_201709_000037")
ctar$traced[ctar$reference.ctar %in% nonbites] <- 1
triage <- triage[which(triage$reference.triage %in% ctar$reference.triage), ] ## only triage with corresponding exposures
ctar <- ctar[which(ctar$reference.triage %in% triage$reference.triage), ] ## only ctar with corresponding exposures

## triage data
triage$triaged <- NA
triage$triaged[triage$triage.status == "Successful"] <- 1
triage$triaged[is.na(triage$triaged)] <- 0
triage$traced <- ctar$traced[match(triage$reference.triage, ctar$reference.triage)]
triage$traced[which(triage$reference.triage %in% ctar$reference.triage[ctar$traced == 1])] <- 1
triage$traced[is.na(triage$traced)] <- 0
nonlinked <- c("TR_201709_000014", "TR_201802_001040", "TR_201802_001045", "TR_201802_001063",  "TR_201802_001107", "TR_201802_001219", "TR_201802_001253", "TR_201802_001332", "TR_201802_001361", "TR_201802_001372", "TR_201709_000031", "TR_201708_000042", "TR_201708_000010", "TR_201708_000001", "TR_201709_000020", "TR_201709_000019", "TR_201709_000035", "TR_201709_000023", "TR_201709_000027", "TR_201710_000025", "TR_201711_000008", "TR_201712_000020", "TR_201712_000027", "TR_201708_000002")
triage$traced[triage$reference.triage %in% nonlinked] <- 1
triage$followedup <- triage$traced + triage$triaged
triage$followedup[triage$followedup > 1] <- 1

## cleaning up statuses
ctar$suspect.exposure <- as.factor(ctar$suspect.exposure)
triage$suspect.animal <- as.factor(triage$suspect.animal)
levels(ctar$suspect.exposure) <- c(levels(ctar$suspect.exposure), "Contact with suspect case")
ctar$suspect.exposure[ctar$consult.type == "Contact with suspect case"] <- "Contact with suspect case"
levels(ctar$suspect.exposure)[levels(ctar$suspect.exposure) == ""] <- "Unknown"
levels(triage$suspect.animal)[levels(triage$suspect.animal) == ""] <- "Unknown"
ctar$followedup <- triage$followedup[match(ctar$reference.triage, triage$reference.triage)]

## folks that reported after tracing
ctar$date.traced <- human$date.traced[match(ctar$ctar.ID, human$ctar.ID)]
date.diff <- ctar$date.traced - ctar$date.reported
date.diff[is.na(date.diff)] <-0
after.tracing <- ctar[date.diff < 0,]
ctar <- ctar[date.diff >= 0, ]
nrow(after.tracing)

ctar$triaged <- triage$triaged[match(ctar$reference.triage, triage$reference.triage)]
## Bite data in Moramanga
ctar %>%
  left_join(select(mada_communes@data, commune, mdg_cm_, mtch_ds), 
                          by = c("commune" = "commune", "district" = "mtch_ds")) %>%
  filter(consult.type == "Animal bite/exposure") %>%
  group_by(mdg_cm_) %>%
  summarize(bites = n()) %>%
  left_join(comm_covars) %>%
  filter(!is.na(ttimes_weighted), district %in% c("Moramanga", "Anosibe-An'ala")) -> bites

```

## Figure 2: Model results Moramanga and District
```{r likelihood of observing moramanga data @ commune level}

get.likelihood.mora <- function(commune, params) {
  # To test likelihood function
  # commune = comm_data
  # district = exps_dist
  # params = c(1e-6, 0.1)
  B_ttimes <- params[1]
  B_0 <- params[2]
  commune %>%
      mutate(bites_mu = exp(B_ttimes*ttimes_weighted + B_0)*pop) -> sum_bites
  return(-sum(dpois(round(sum_bites$bites), lambda = sum_bites$bites_mu, log = TRUE)))
}

get.likelihood <- function(commune, district, params) {
  # To test likelihood function
  # commune = comm_data
  # district = exps_dist
  # params = c(1e-6, 0.1)
  B_ttimes <- params[1]
  B_0 <- params[2]
  commune %>%
      filter(exclude == 0) %>%
      group_by(mdg_dis_co) %>%
      mutate(bites = exp(B_ttimes*ttimes_weighted + B_0)*pop) %>%
      summarize(sum_bites = sum(bites)) %>%
      left_join(select(district, district, dist_bites = bites), 
                by = c("mdg_dis_co" = "district")) %>%
      filter(!is.na(dist_bites)) -> sum_bites
  return(-sum(dpois(round(sum_bites$dist_bites), lambda = sum_bites$sum_bites, log = TRUE)))
}
```

```{r likelihood of observing district data given sum of communes in district}
bites$bites <- round(bites$bites/18*12)
mora_pars <- optim(par = c(1e-6, 0.1), get.likelihood.mora, commune = bites, hessian = TRUE)
B_ttimes_mora <- mora_pars$par[1]
B_0_mora <- mora_pars$par[2]

## Getting standard errors
# this is how you can get standard errors from optim, but inverting the hessian
se <- sqrt(abs(diag(solve(mora_pars$hessian)))); se

#simulate "standard errors"
varcov <- solve(mora_pars$hessian)
library(MASS)

ntest = 1000; testpar = mora_pars$par; sim.par = matrix(NA, ntest, 2)
for (k in 1:ntest) {
  sim.par[k, ] = mvrnorm(1, mora_pars$par, varcov)
}

B_ttimes_mora_CI <- quantile(sim.par[,1],c(0.025,0.975))
B_0_mora_CI <- quantile(sim.par[,2],c(0.025,0.975))

mada_pars <- optim(par = c(1e-6, 0.1), get.likelihood, district = exps_dist,
             commune = comm_data, hessian = TRUE)
B_ttimes_mada <- mada_pars$par[1]
B_0_mada <- mada_pars$par[2]

## Getting standard errors
# this is how you can get standard errors from optim, but inverting the hessian
se <- sqrt(abs(diag(solve(mada_pars$hessian)))); se

#simulate "standard errors"
varcov <- solve(mada_pars$hessian)
library(MASS)

ntest = 1000; testpar = mada_pars$par; sim.par = matrix(NA, ntest, 2)
for (k in 1:ntest) {
  sim.par[k, ] = mvrnorm(1, mada_pars$par, varcov)
}

B_ttimes_mada_CI <- quantile(sim.par[,1],c(0.025,0.975))
B_0_mada_CI <- quantile(sim.par[,2],c(0.025,0.975))
par_df <- data.frame(values = c(B_ttimes_mada, B_ttimes_mora, B_0_mada, B_0_mora),  
                     par = c("B_ttimes", "B_ttimes", "intercept", "intercept"),
                     upper_CI = c(CI = B_ttimes_mada_CI[2], B_ttimes_mora_CI[2],
                                  B_0_mada_CI[2], B_0_mora_CI[2]),
                     lower_CI = c(CI = B_ttimes_mada_CI[1], B_ttimes_mora_CI[1],
                                  CI = B_0_mada_CI[1], B_0_mora_CI[1]),
                     model = c("Mada", "Mora", "Mada", "Mora"))

ggplot(data = par_df, aes(x = model, y = values)) +
  geom_point() +
  geom_linerange(aes(ymin = lower_CI, ymax = upper_CI)) +
  coord_flip() 

ggplot(data = filter(par_df, par == "intercept"), aes(x = model, y = values)) +
  geom_point() +
  geom_errorbar(aes(ymin = lower_CI, ymax = upper_CI))

ttimes_plot <- seq(0, 15*60, by = 30)
pop_plot <- 1e5

## Mada
plot(ttimes_plot/60, exp(B_ttimes_mada*ttimes_plot + B_0_mada)*pop_plot, type = "l", bty = "n",
     ylab = "Mean bites per 100k", xlab = "Travel times (hrs)", col = "darkblue")
points(ttimes_plot/60, exp(B_ttimes_mada_CI[1]*ttimes_plot + B_0_mada_CI[1])*pop_plot, type = "l", 
       lty = 2, col = "lightblue")
points(ttimes_plot/60, exp(B_ttimes_mada_CI[2]*ttimes_plot + B_0_mada_CI[2])*pop_plot, type = "l", 
       lty = 2, col = "lightblue")

points(ttimes_plot/60, exp(B_ttimes_mora*ttimes_plot + B_0_mora)*pop_plot, type = "l", col = "purple")
points(ttimes_plot/60, exp(B_ttimes_mora_CI[1]*ttimes_plot + B_0_mora_CI[1])*pop_plot, type = "l", 
       lty = 2, col = "magenta")
points(ttimes_plot/60, exp(B_ttimes_mora_CI[2]*ttimes_plot + B_0_mora_CI[2])*pop_plot, type = "l",
       lty = 2, col = "magenta")
legend("topright", c("Mada", "Mora", "CIs"), col = c("darkblue", "purple", "grey"), lty = c(1, 1, 2), 
       bty = "n")

## Data vs. predicted
comm_data %>%
      filter(exclude == 0) %>%
      group_by(mdg_dis_co) %>%
      mutate(bites = exp(B_ttimes*ttimes_weighted + B_0)*pop) %>%
      summarize(sum_bites = sum(bites)) %>%
      left_join(select(exps_dist, district, dist_bites = bites), 
                by = c("mdg_dis_co" = "district")) %>%
      filter(!is.na(dist_bites)) -> sum_bites
sum_bites %$% plot(dist_bites, sum_bites, bty = "n", pch = 20, 
                   xlab = "Observed mean bites at district (Mada)", ylab = "Model predicted mean bites")
abline(a = 0, b = 1, col = "blue", lty = 2)

bites %>%
      mutate(bites_mu = exp(B_ttimes*ttimes_weighted + B_0)*pop) -> check
plot(check$bites, check$bites_mu, bty = "n", pch = 20, 
      xlab = "Observed mean bites at commune (Moramanga)", ylab = "Model predicted mean bites")
abline(a = 0, b = 1, col = "blue", lty = 2)

```

```{burden by incidence}

## Mada
plot(ttimes_plot/60, exp(B_ttimes_mada*ttimes_plot + B_0_mada)*pop_plot, type = "l", bty = "n",
     ylab = "Mean bites per 100k", xlab = "Travel times (hrs)", col = "darkblue")
points(ttimes_plot/60, exp(B_ttimes_mada_CI[1]*ttimes_plot + B_0_mada_CI[1])*pop_plot, type = "l", 
       lty = 2, col = "lightblue")
points(ttimes_plot/60, exp(B_ttimes_mada_CI[2]*ttimes_plot + B_0_mada_CI[2])*pop_plot, type = "l", 
       lty = 2, col = "lightblue")
abline(h = pop_plot/25*0.01*0.39, col = "darkred") # low rabies incidence
abline(h = pop_plot/5*0.01*0.39, col = "red") # high rabies incidence

bites_100k <- exp(B_ttimes_mada*ttimes_plot + B_0_mada)*pop_plot
R_100k_min <- pop_plot/25*0.01*0.39
R_100k_max <- pop_plot/5*0.01*0.39

plot(ttimes_plot/60, 
     bites_100k*(ifelse(bites_100k*0.6 > R_100k_min, R_100k_min/bites_100k, 0.6))/R_100k_min, 
     type = "l", bty = "n",
     ylab = "Reporting", xlab = "Travel times (hrs)", col = "darkred")
lines(ttimes_plot/60, 
     bites_100k*(ifelse(bites_100k*0.2 > R_100k_max, R_100k_max/bites_100k, 0.2))/R_100k_max,
     col = "red")

ests_lower <- predict(mod_lower, newdata = as.data.frame(ttimes_plot), 
                                type = "response")
ests_upper <- predict(mod_upper, newdata = as.data.frame(ttimes_plot), 
                                type = "response")

plot(ttimes_plot/60, 
     bites_100k*(ifelse(bites_100k*ests_upper > R_100k_min, R_100k_min/bites_100k,
                        ests_upper))/R_100k_min, 
     type = "l", bty = "n",
     ylab = "Reporting", xlab = "Travel times (hrs)", col = "darkred")
lines(ttimes_plot/60, 
     bites_100k*(ifelse(bites_100k*ests_lower > R_100k_max, R_100k_max/bites_100k,
                        ests_lower))/R_100k_max,
     col = "red")

```


## Summary of analyses: Models of proportion rabid as a function of travel time, Moramanga District
- We use a generalized linear model with a binomial link function where the response is the number of rabid cases triaged/traced (with the # trials as the total # of triaged/traced patients in the commune and the predictor is the travel times. 
  - the lower end of the number of rabid cases as the number of confirmed rabid and probable status
  - the higher end of the number of rabid cases includes those of unknown exposure status
```{r model of p_rabid}
ctar %>%
  left_join(select(mada_communes@data, commune, mdg_cm_, mtch_ds), 
                          by = c("commune" = "commune", "district" = "mtch_ds")) %>%
  filter(triaged == 1, consult.type != "Contact with suspect case") %>%
  dplyr::select(mdg_cm_, suspect.exposure) %>%
  gather(suspect.exposure, value, -mdg_cm_) %>%
  group_by(mdg_cm_, value) %>%
  tally %>%
  spread(value, n, fill = 0) %>%
  mutate(total = Confirmed + No + Probable + Unknown, 
         rabid_upper = Confirmed + Probable + Unknown,
         rabid_lower = Confirmed + Probable) %>% 
  left_join(comm_covars) %>%
  filter(!is.na(ttimes_weighted), district != "Antananarivo Renivohitra") -> prop_rabid

## Model of proportion rabid
prop_rabid %$% plot(ttimes_weighted, rabid_lower/total)
mod_lower <- glm(cbind(rabid_lower, total - rabid_lower) ~ ttimes_weighted, data = prop_rabid, 
           family = binomial)
prop_rabid %$% plot(rabid_lower/total, predict(mod_lower, type = "response"), 
                    ylim = c(0, 1), xlim = c(0, 1), bty = "n", xlab = "Observed proportion rabid",
                    ylab = "Model predicted proportion rabid", cex = log(total + 0.01)/2)
abline(a = 0, b = 1, lty = 2, col = "blue")
prop_rabid %$% plot(ttimes_weighted/60, predict(mod_lower, type = "response"), ylim = c(0, 1), 
                    bty = "n", xlab = "Travel times (hrs)", ylab = "Proportion rabid", 
                    pch = 20, col = "darkblue")
prop_rabid %$% points(ttimes_weighted/60, rabid_lower/total, col = "blue", cex = log(total + 0.01)/2)
legend("topright", inset = c(-0.3, -0.2), legend = c("Model predicted", "Observed"), 
       col = c("darkblue", "blue"), pch = c(20, 1), bty = "n", xpd = TRUE)

mod_upper <- glm(cbind(rabid_upper, total - rabid_upper) ~ ttimes_weighted, data = prop_rabid, 
           family = binomial)
prop_rabid %$% plot(rabid_upper/total, predict(mod_upper, type = "response"), 
                    ylim = c(0, 1), xlim = c(0, 1), bty = "n", xlab = "Observed proportion rabid",
                    ylab = "Model predicted proportion rabid", cex = log(total + 0.01/2))
abline(a = 0, b = 1, lty = 2, col = "blue")
prop_rabid %$% plot(ttimes_weighted/60, predict(mod_upper, type = "response"), ylim = c(0, 1), 
                    bty = "n", xlab = "Travel times (hrs)", ylab = "Proportion rabid", 
                    pch = 20, col = "darkblue")
prop_rabid %$% points(ttimes_weighted/60, rabid_upper/total, col = "blue", cex = log(total + 0.01)/2)

ttimes_weighted <- ttimes_plot
prop_rabid %$% plot(ttimes_plot/60, predict(mod_lower, newdata = as.data.frame(ttimes_plot), 
                                            type = "response"), 
                    ylim = c(0, 1), 
                    bty = "n", xlab = "Travel times (hrs)", ylab = "Proportion rabid", 
                    type = "l", col = "darkblue")
prop_rabid %$% points(ttimes_weighted/60, rabid_lower/total, col = "blue", cex = log(total + 0.01)/2)

prop_rabid %$% points(ttimes_plot/60, predict(mod_upper, newdata = as.data.frame(ttimes_plot),
                                              type = "response"), type = "l", col = "red")
prop_rabid %$% points(ttimes_weighted/60, rabid_upper/total, col = "red", cex = log(total + 0.01)/2)
legend("topright", inset = c(-0.3, -0.3), legend = c("Upper observed", "Lower observed"), 
       col = c("Red", "Blue"), pch = 1, bty = "n", xpd = TRUE)
legend("topright", inset = c(-0.25, -0.15), legend = c("Upper model", "Lower model"), 
       col = c("Red", "Blue"), lty = 1, bty = "n", xpd = TRUE)
```

## Figure 3: Proportion rabid models

## Estimating burden
- We used our model to predict average annual bite incidence to the commune level given our model:
- We calculated deaths as:
$$ 
      deaths_{i} = (R_{i} - ({p_{rabid} \times B_{i})) \times p_{death}
$$
- where the proportion of reported bites that are rabies exposures ($p_{rabid}$) are defined as:
$$
           p_{rabid}=
            \begin{cases}
            x, & \text{if}\ \frac{R_i \times \rho_{max}}{B_i} > x \\
            \frac{R_i}{B_i}, & \text{otherwise}
            \end{cases}
$$
<br>

such that rabid reported bites (i.e. $p_{rabid}\timesB_{i}$) cannot exceed the expected number of human exposures given maximum reporting (i.e. $R_{i} \times \rho_{max}$. $p_{rabid}$ is taken from Rajeev et al. 2018 on contact tracing data from the Moramanga District. 

## Estimating burden
$R_{i}$ is drawn from a uniform distribution between the minimum and maximum expected number of human exposures. We calculate this as:
    
<br>

$$r \times D \times p_{exp}$$ 
    
<br>

where $r$ is rabies incidence in dogs in the absence of any vaccination multiplied by the estimated dog population in the commune ($D_i$) and the exposure rate per rabid dogs ($p_{exp}$ = 0.39 persons exposed per rabid dog)(Hampson et al. 2018). 

- We estimate the dog population by using a human:dog ratio of 5 to generate our maximum expected incidence and an HDR of 25 for our minimum expected incidence.

## Figure 4: Burden estimates

```{r functions for getting burden}
get.burden <- function(comm = comm_data, B_ttimes = B_ttimes_mada, B_0 = B_0_mada, 
                       pop = comm_data$pop,
                       p_rabid = 0.5, rho_max = 0.9,
                       max_HDR = 25, min_HDR = 5, 
                       dog_rabies_inc = 0.01, human_exp_rate = 0.39, 
                       prob_death = 0.16, nsims = 1000) {
  store_deaths <- store_p_rabid <- matrix(NA, nrow(comm), nsims)

  for (i in 1:nsims) {
    mean_bites <- exp(B_ttimes*comm$ttimes_weighted + B_0)*comm$pop
    bites <- rpois(length(mean_bites), mean_bites)
    mean_exps <- runif(length(pop), min = human_exp_rate*dog_rabies_inc*pop/max_HDR, 
                    max = human_exp_rate*dog_rabies_inc*pop/min_HDR)
    rabid_exps <- rpois(length(mean_bites), mean_exps)
    p_rabid_t <- ifelse(bites*p_rabid/rabid_exps > rho_max, (rho_max*rabid_exps)/bites, p_rabid)
    deaths <- rbinom(length(mean_bites), rabid_exps - round(bites*p_rabid_t), prob_death)
    store_deaths[, i] <- deaths
    store_p_rabid[, i] <- p_rabid_t
  }
  
  results <- cbind(get.meanCI(store_deaths), get.meanCI(store_p_rabid))
  colnames(results) <- c("deaths_mean", "deaths_lowerCI", "deaths_upperCI",
                         "p_rabid_mean", "p_rabid_lowerCI", "p_rabid_upperCI")
  results <- cbind(covars, results)
  return(results)
}

get.burden.flat <- function(covs = covars, pop = covars$pop, model = mod,
                       p_rabid = 0.5, rho = 0.85, 
                       prob_death = 0.16, nsims = 1000) {
  store_deaths <- matrix(NA, nrow(covs), nsims)

  for (i in 1:nsims) {
    mean_bites <- predict(model, type = "response", newdata = covs)
    bites <- rpois(length(mean_bites), mean_bites)
    unreported <- bites*p_rabid/rho - bites*p_rabid
    deaths <- rbinom(length(mean_bites), round(unreported), prob_death)
    store_deaths[, i] <- deaths
  }
  results <- get.meanCI(store_deaths)
  colnames(results) <- c("deaths_mean", "death_lowerCI", "deaths_upperCI")
  results <- cbind(covars, results)
  return(results)
}

get.meanCI <- function(matrix_by_row, nboots = 1000) {
    mean_rows <- apply(matrix_by_row, 1, mean)
    CIs <- apply(matrix_by_row, 1, boots, nboot = nboots)
    lower <- unlist(CIs)[1, ] 
    upper <- unlist(CIs)[2, ]
    summ <- cbind(mean_rows, lower, upper)
    colnames(summ) <- c("mean", "lower", "upper")
    return(summ)
}

boots <- function(x, nboot = 1000){
  n = length(x)
  xbar = mean(x)
  tmpdata = sample(x,n*nboot, replace=TRUE)
  bootstrapsample = matrix(tmpdata, nrow=n, ncol=nboot)
  bsmeans = colMeans(bootstrapsample)
  deltastar = bsmeans - xbar
  d = quantile(deltastar, c(0.05, 0.95), na.rm = TRUE)
  ## Get from quantiles
  ci = xbar - c(d[2], d[1])

  ## Sorted CIs
  sorteddeltastar = sort(deltastar)
  # # Look at the sorted results
  # Find the .05 and .95 critical values of deltastar
  d9alt = sorteddeltastar[5]
  d1alt = sorteddeltastar[950]
  # Find and print the 80% confidence interval for the mean
  ciAlt = xbar - c(d1alt,d9alt)
  # cat(’Alternative confidence interval: ’,ciAlt, ’\n’)
  return(ci)
}

```

```{r}
results_pr20 <- get.burden(p_rabid = 0.20, rho_max = 0.98)
results_pr60 <- get.burden(p_rabid = 0.60,rho_max = 0.98)

plot(results_pr20$ttimes_weighted/60, results_pr20$deaths_mean, col = "darkred", pch = 20)
points(results_pr60$ttimes_weighted/60, results_pr60$deaths_mean, col = "red", pch = 20)
segments(x0 = results_pr60$ttimes_weighted/60, x1 = results_pr60$ttimes_weighted/60,
         y0 = results_pr60$deaths_mean, y1 = results_pr20$deaths_mean, col = "red")
```



Generally, estimated reporting decayed with travel times given model predicted bite incidence and a range of rabies incidence and $p_{rabid}$ (Figure 5A). Given our model assumptions, reporting was estimated at the maximum of 0.98 for travel times under `r max(ttimes_plot[bites_100k*0.2 > R_100k_max])/60` given the maximum estimated rabies exposure incidence and the minimum estimate of $p_{rabid}$ (the lower range of reporting probabilities), and travel times under `r max(ttimes_plot[bites_100k*0.6 > R_100k_min])/60` given the minimum estimated rabies exposure incidence and the maximum estimate of $p_{rabid}$ (the upper range of reporting probabilities). 

```{r functions for getting burden}

boots <- function(x, nboot = 1000){
  n = length(x)
  xbar = mean(x)
  tmpdata = sample(x,n*nboot, replace=TRUE)
  bootstrapsample = matrix(tmpdata, nrow=n, ncol=nboot)
  bsmeans = colMeans(bootstrapsample)
  deltastar = bsmeans - xbar
  d = quantile(deltastar, c(0.05, 0.95), na.rm = TRUE)
  ## Get from quantiles
  ci = xbar - c(d[2], d[1])

  ## Sorted CIs
  sorteddeltastar = sort(deltastar)
  # # Look at the sorted results
  # Find the .05 and .95 critical values of deltastar
  d9alt = sorteddeltastar[5]
  d1alt = sorteddeltastar[950]
  # Find and print the 80% confidence interval for the mean
  ciAlt = xbar - c(d1alt,d9alt)
  # cat(’Alternative confidence interval: ’,ciAlt, ’\n’)
  return(ci)
}

get.meanCI <- function(matrix_by_row, nboots = 1000) {
    mean_rows <- apply(matrix_by_row, 1, mean)
    CIs <- apply(matrix_by_row, 1, boots, nboot = nboots)
    lower <- unlist(CIs)[1, ] 
    upper <- unlist(CIs)[2, ]
    summ <- cbind(mean_rows, lower, upper)
    colnames(summ) <- c("mean", "lower", "upper")
    return(summ)
}

get.burden <- function(covars = comm_data, ttimes = comm_data$ttimes_weighted, pop = comm_data$pop, 
                       param_ttimes = B_ttimes_mada,
                       param_intercept = B_0_mada,
                       p_rabid = 0.5, rho_max = 0.9,
                       max_HDR = 25, min_HDR = 5, 
                       dog_rabies_inc = 0.01, human_exp_rate = 0.39, 
                       prob_death = 0.16, nsims = 1000) {
  
  store_deaths <- store_p_rabid <- matrix(NA, length(ttimes), nsims)

  for (i in 1:nsims) {
    ## for testing
    # covars = comm_data; ttimes = comm_data$ttimes_weighted; pop = comm_data$pop;
    #                    param_ttimes = B_ttimes_mada;
    #                    param_intercept = B_0_mada;
    #                    p_rabid = 0.5; rho_max = 0.9;
    #                    max_HDR = 25; min_HDR = 5;
    #                    dog_rabies_inc = 0.01; human_exp_rate = 0.39;
    #                    prob_death = 0.16;
                       
    bites <- rpois(length(ttimes), exp(param_ttimes*ttimes + param_intercept)*pop)
    mean_exps <- runif(length(pop), min = human_exp_rate*dog_rabies_inc*pop/max_HDR, 
                    max = human_exp_rate*dog_rabies_inc*pop/min_HDR)
    rabid_exps <- rpois(length(mean_exps), mean_exps)
    p_rabid_t <- ifelse(bites == 0 & rabid_exps == 0, 0,
                        ifelse(bites*p_rabid/rabid_exps > rho_max, (rho_max*rabid_exps)/bites, p_rabid))
    reported_rabid <- round(bites*p_rabid_t)
    reported_rabid <- ifelse(reported_rabid > rabid_exps, rabid_exps, reported_rabid)
    deaths <- rbinom(length(ttimes), rabid_exps - reported_rabid, prob_death)
    store_deaths[, i] <- deaths
    store_p_rabid[, i] <- p_rabid_t
  }
  
  results <- cbind(get.meanCI(store_deaths), get.meanCI(store_p_rabid))
  colnames(results) <- c("deaths_mean", "deaths_lowerCI", "deaths_upperCI",
                         "p_rabid_mean", "p_rabid_lowerCI", "p_rabid_upperCI")
  results <- cbind(covars, results)
  return(results)
}

get.burden.flat <- function(covars = comm_data, ttimes = comm_data$ttimes_weighted, pop = comm_data$pop, 
                       param_ttimes = B_ttimes_mada,
                       param_intercept = B_0_mada,
                       p_rabid = 0.5, rho = 0.9,
                       max_HDR = 25, min_HDR = 5, 
                       dog_rabies_inc = 0.01, human_exp_rate = 0.39, 
                       prob_death = 0.16, nsims = 1000) {
  
  store_deaths <- matrix(NA, length(ttimes), nsims)

  for (i in 1:nsims) {
    bites <- rpois(length(ttimes), exp(param_ttimes*ttimes + param_intercept)*pop)
    reported_rabid <- rbinom(length(ttimes), size = bites, prob = 0.5)
    total_rabid <- round(reported_rabid/rho)
    deaths <- rbinom(length(mean_bites), total_rabid - reported_rabid, prob_death)
    store_deaths[, i] <- deaths
  }
  
  results <- get.meanCI(store_deaths)
  colnames(results) <- c("deaths_mean", "deaths_lowerCI", "deaths_upperCI")
  results <- cbind(covars, results)
  return(results)
}


```


```{r}
results_pr20 <- get.burden(p_rabid = 0.20, rho_max = 0.98)
results_pr60 <- get.burden(p_rabid = 0.60,rho_max = 0.98)
results_pr20$pr <- "0.20"
results_pr60$pr <- "0.60"
results <- rbind(results_pr20, results_pr60)

results %>% 
  group_by(mdg_dis_co, pr) %>% 
  summarize(tot = sum(deaths_mean), upperCI = sum(deaths_upperCI), lowerCI = sum(deaths_lowerCI)) %>%
  left_join(dist_catchments) %>% 
  left_join(select(mada_district@data, mdg_dis_co, district)) %>%
  ggplot(., aes(y = reorder(district, ttimes_weighted), x = tot, color = pr)) +
  ggstance::geom_pointrangeh(aes(xmin = lowerCI, xmax = upperCI), fatten = 2) +
  ylab("") +
  xlab("Average annual deaths") +
  scale_color_manual(values = c("0.20" = alpha("red", 0.2), "0.60" = alpha("red", 0.6)), 
                     name = "Proportion rabid") -> p
p + theme(axis.text.y = element_text(margin = margin(t = 10, r = 0, b = 10, l = 0), size = 7)) 

```

When we estimate burden of deaths stochastically within this range of incidence and given our high and low estimates of proportion of reported bites that are rabid, we see that burden of deaths also decreases with travel times (Figure 6, results presented aggregated at the district level). Overall, we estimate average annual deaths between `r round(sum(results_pr60$deaths_mean))` - `r round(sum(results_pr20$deaths_mean))`. **Also estimate deaths averted here!**. 

### Burden sensitivity analyses
- Compare to assuming flat reporting + bite model
- $\rho_{max}$, change by urban vs. rural commune?
- If rabies incidence, $R$, scales with population size within our estimated range
- Impacts on # of deaths vs. change in scenarios (i.e. focusing on relative decreases in incidence of deaths based on expanded access rather than raw #s)

<br>

## Discussion

### Key findings

### Strengths and Limitations
- Not accounting for clinic functioning
- Not explicit data on reporting or rabies incidence!
- Other factors that drive reporting
- While we use a signficiant amount of assumptions, these are the same set of assumptions that underlie current rabies estimates, we're just improving them a bit... and ours are a likely a little bit more in line with reality @ a sub-national level?

### Broader context

### Conclusions

