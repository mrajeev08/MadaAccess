---
title: "PEP Access"
author: "Malavika Rajeev"
date: "6/25/2018"
output: html_document
---
```{r directory, include=FALSE}
rm(list = ls())
require("knitr")
opts_knit$set(root.dir = "/Users/mrajeev/Dropbox/MadaPEP")
```

## Data [Show figure from paper]
* Commune level average travel time to the closest CTAR (where PEP is available).
* Human population per commune extracted from World Pop
* 16 months of data on reported animal bites from the Moramanga District in Madagascar 
  - Use to calculate the annual # of reported bites per 100,000 persons.

```{r setup, include=FALSE}
## libraries
# for gis 
library(knitr)
library(raster)
library(maptools)
library(maps)
library(GISTools)
library(rgdal)
library(sp)
library(rgdal)
library(gdistance)
# everything else
library(lubridate)
library(reshape2)
library(tidyverse)
library(rjags)
library(coda)
library(lattice)
# pkgs <- c("lattice", "coda")
# require(pkgs, character.only = TRUE)

## gis data {NEED TO FIGURE OUT PROJECTIONS!}
p4s <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

## data
exposure.mat <- read.csv("data/exposures_by_commune_Moramanga.csv", header = TRUE, row.names = 1)
moramanga <- readOGR("data/MoramangaGIS/MoramangaPops.shp")
ctar.gps <- read.csv("data/ctar_gps.csv")

## data
monthly.bites <-rowSums(exposure.mat)/ncol(exposure.mat)
moramanga$commune.midpops <- (moramanga$pop2015adj + moramanga$pop2020adj)/2
moramanga$monthly.bites <- monthly.bites[match(moramanga$commune, names(monthly.bites))]
moramanga$monthly.incidence <- moramanga$monthly.bites/moramanga$commune.midpops*1e5

## travel time layer
travel.times <- raster("output/study.area.accessibility.tif")
mora.access <- mask(travel.times, moramanga)
mora.access <- crop(mora.access, moramanga)
moramanga <- raster::extract(mora.access, moramanga, fun = mean, na.rm=TRUE, df = TRUE, sp = TRUE)
moramanga$comm.long <- coordinates(moramanga)[,1]
moramanga$comm.lat <- coordinates(moramanga)[,2]

# plot it
plot(mora.access/60,
     breaks = c(0, 1, 2, 3, 4, 5, 6, 7,8, 16, max(values(mora.access)/60, na.rm = TRUE)),
     col = c("#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", 
             "#ae017e", "#7a0177", "#49006a"), axes = FALSE, box = FALSE)
points(moramanga$comm.long[moramanga$commune == "Moramanga"], moramanga$comm.lat[moramanga$commune == "Moramanga"], pch = 18, col = "grey", cex = 2)

```


## Rationale
Access to PEP is geographically limited in Madagascar, with PEP available in only 31 clinics across the country. Therefore the burden of human rabies deaths is likely heterogeneous spatially. 

Standard decision tree models using overall reported bites would estimate rabies exposure incidence ($R$) as:
$$ R = \frac{B\times p_{rabid}}{p_{report}} $$

where *B* is the total reported bites, *p_rabid* is the probability that a reported animal bite is a genuine rabies exposure, *p_report* is the probability that a rabies exposure is reported. 

We generate high and low estimates of expected rabies incidence ($R$) using estimates from a recent modeling study that generated incidence of human exposures per 100,000 dogs in a no-vaccination scenario and given high and low estimates of human:dog ratios. We can do this in Madagascar because there's no vacc going on!

Applying this framework to our data on reported bites in the Moramanga District, we see that estimated rabies incidence exceeds expected incidence in areas with high incidence of reported bites and is lower than expected for areas with little data/low incidence of reported bites (Figure 1). 

Aside for Jess: this is the same issue if we fit bites as a function of travel times + pop (lower reported bites in )
```{r standard decision tree }
## adding in expected exposures annually
# rabies incidence per 100kdogs/# of human exps per rabid dog/human:dog ratio = inc per 100k persons
exps.per100k.high <- 1000*0.39/5 
exps.per100k.low <- 600*0.39/25

ordered.bites <- moramanga$monthly.incidence[order(moramanga$commune.midpops)]*12
par(mar = c(4, 10, 2, 2))
plot(ordered.bites*0.6/0.85, 1:length(monthly.bites), bty = "l", pch = 20, col = "darkred", 
     xlab = "Rabies exposures per 100k persons", ylab = "", axes = FALSE, 
     xlim = c(0, max(ordered.bites*0.6/0.85)+100))
axis(1)
text(moramanga$commune[order(moramanga$commune.midpops)], y = 1:length(monthly.bites), x = -10, adj = 1, xpd = TRUE)
points(ordered.bites*0.2/0.85, 1:length(monthly.bites),
       pch = 20, col = "darkred")
segments(y0 = 1:length(monthly.bites), x0 = ordered.bites*0.2/0.85,
         y1 = 1:length(monthly.bites),
         x1 = ordered.bites*0.6/0.85, col = "darkred")
abline(v = c(exps.per100k.high, exps.per100k.low), col = c("red", "red"), lty = 2)
legend("topleft", "Range of expected \n rabies incidence", col = "red", lty = 2, bty = "n",
       inset = c(0.4, 0), xpd = TRUE, x.intersp = 0.2, seg.len = 1)
```

## Empirical estimates of p_report for each location across a range of scenarios
We can calculate p_report empirically assuming incidence and p_rabid is uniform:
$$ p_{report} = \frac{B\times p_{rabid}}{R}$$

We constrain $p_{rabid}$ so that p_report cannot exceed 1:
    $$
           p_{rabid}=
            \begin{cases}
            1, & \text{if}\ \frac{R}{B} > 1 \\
            \frac{R}{B}, & \text{otherwise}
            \end{cases}
    $$
which would give us the highest estimates of reporting for a given incidence level (assumes that the maximum # of bites are reported the $\frac{R}{B} > 1$ and that reporting = 1 when $\frac{R}{B} < 1$).

```{r empirical p_reports}
p_rabid_high <- exps.per100k.high/(moramanga$monthly.incidence*12)
p_rabid_high[p_rabid_high >= 0.95] <- 0.95
p_rabid_low <- exps.per100k.low/(moramanga$monthly.incidence*12)
p_rabid_low[p_rabid_low >= 0.95] <- 0.95

## p_report
plot(moramanga$study.area.accessibility/60, 
     moramanga$monthly.incidence*12*p_rabid_high/exps.per100k.high, ylim = c(0, 1), 
     col = "red", pch = 20, bty = "l", xlab = "Travel times (hrs)", ylab = "Reporting")
points(moramanga$study.area.accessibility/60, 
     moramanga$monthly.incidence*12*p_rabid_low/exps.per100k.low,  
     col = "darkred")
segments(x0 = moramanga$study.area.accessibility/60, y0 = moramanga$monthly.incidence*12*p_rabid_low/exps.per100k.low,
         x1 = moramanga$study.area.accessibility/60,
         y1 = moramanga$monthly.incidence*12*p_rabid_high/exps.per100k.high, col = "darkred")
legend("topright", c("High incidence", "Low incidence"), col = c("Red", "darkred"), pch = c(20, 1), 
       bty = "n", inset = c(-0.2, 0), xpd = TRUE)
```


## Models of reporting by travel time to clinic
To generate more probable estimates of rabies burden given what we know about access to PEP in Maadagascar, we use assumptions of rabies exposure incidence and our data on reported bites to estimate $p_{report}$ based on our original decision tree:
$B = \frac{R\times p_{report}}{p_{rabid}}$

We  estimate a commune specific reporting rate as a function of travel times to the nearest ARMC and we say that $p_{rabid} scales inversely with the number of reported rabid bites (so that as more rabid bites are reported, more normal bites per rabid bites are reported as well). We say tha
 
```{r Annual jags model with p_rabid + p_report estimated, high incidence}
### data
bites <- round(moramanga$monthly.bites*12)
ttimes <- moramanga$study.area.accessibility/60
pop <- moramanga$commune.midpops
nlocs <- length(bites)
expected.mean <- exps.per100k.high/2*moramanga$commune.midpops/1e5

## model
tt.model <- "model {
# reported bites
for (j in 1:nlocs){
# Number of bites
  bites[j] ~ dpois(expected.mean[j]*rho[j]/p_rabid[j])
}

# spatial effects
  for (g in 1:nlocs){
  # Spatial random effect
  loc_eff[g] ~ dnorm(0, tau_loc)

  # Reporting in place g
  logit(rho[g]) <- B_tt*(1/ttimes[g]) + loc_eff[g]

  # Background avg in place g
  p_rabid[g] <- 1/(1 + sqrt(expected.mean[g]*rho[g])*B_norm)
}

tau_loc <- 1/sd

# priors
B_tt ~ dnorm(0, 0.1)
sd ~ dnorm(0, 0.1)
B_norm ~ dnorm(0.1, 0.1)
}"


data <- list (bites = bites, 
              expected.mean = expected.mean,
              ttimes = ttimes, nlocs = nlocs)

inits <- list(B_tt = rnorm(1, 0, 1e-6), sd = 1,
              B_norm = rnorm(1, 0, 1e-6))

jags_mod <- jags.model(textConnection(tt.model), data = data, inits = inits, n.chains = 5, 
                       n.adapt = 1000)

params <- c("B_tt", "sd", "B_norm")

samps <- coda.samples(jags_mod, params, n.iter = 10000)
burn.in <- 5000
check <- summary(window(samps, start = burn.in))
check
par(mar = c(2, 2, 2, 2))
plot(samps)
# gelman.plot(samps)
gelman.diag(samps)

## parameter estimates
par(mfrow = c(2, 1), mar = c(5, 5, 2,  2))
plot(expected.mean, 1/(1 + sqrt(expected.mean)*check$statistics[,"Mean"]["B_norm"]), bty = "l",
     pch = 20, xlab = "Expected incidence", ylab = "P_rabid")
plot(ttimes, plogis(check$statistics[,"Mean"]["B_tt"]*(1/ttimes) 
                    + rnorm(length(ttimes), mean = 0, sd = check$statistics[,"Mean"]["sd"])),
     bty = "l", pch = 20, xlab = "Travel times (hrs)", ylab = "P_report")

## mean and confidence interval
sims = 1000
bites.sim.high <- matrix(0, nrow = sims, ncol = length(bites))
for (i in 1:sims){
  rho <- plogis(check$statistics[,"Mean"]["B_tt"]*(1/ttimes) 
                    + rnorm(length(ttimes), mean = 0, sd = check$statistics[,"Mean"]["sd"]))
  p_rabid <- 1/(1 + sqrt(expected.mean*rho)*check$statistics[,"Mean"]["B_norm"])
  bites.sim.high[i, ] <- rpois(length(p_rabid), expected.mean*rho/p_rabid)
}
rankCI <- function(x){
  upper <- x[order(x)][0.95*length(x)]
  lower <- x[order(x)][0.05*length(x)]
  return(c(lower, upper))
}

upper.CI.high <- apply(bites.sim.high, 2, rankCI)[2,]
lower.CI.high <- apply(bites.sim.high, 2, rankCI)[1,]
```


```{r Annual jags model with p_rabid + p_report estimated, low incidence}
### data
expected.mean <- exps.per100k.low/2*moramanga$commune.midpops/1e5

data <- list (bites = bites, 
              expected.mean = expected.mean,
              ttimes = ttimes, nlocs = nlocs)

inits <- list(B_tt = rnorm(1, 0, 1e-6), sd = 1,
              B_norm = rnorm(1, 0, 1e-6))

jags_mod <- jags.model(textConnection(tt.model), data = data, inits = inits, n.chains = 5, 
                       n.adapt = 1000)

params <- c("B_tt", "sd", "B_norm")

samps <- coda.samples(jags_mod, params, n.iter = 10000)
burn.in <- 5000
check <- summary(window(samps, start = burn.in))
check
par(mar = c(2, 2, 2, 2))
plot(samps)
# gelman.plot(samps)
gelman.diag(samps)

## parameter estimates
par(mfrow = c(2, 1), mar = c(5, 5, 2,  2))
plot(expected.mean, 1/(1 + sqrt(expected.mean)*check$statistics[,"Mean"]["B_norm"]), bty = "l",
     pch = 20, xlab = "Expected incidence", ylab = "P_rabid")
plot(ttimes, plogis(check$statistics[,"Mean"]["B_tt"]*(1/ttimes) 
                    + rnorm(length(ttimes), mean = 0, sd = check$statistics[,"Mean"]["sd"])),
     bty = "l", pch = 20, xlab = "Travel times (hrs)", ylab = "P_report")

## mean and confidence interval
sims = 1000
bites.sim.low <- matrix(0, nrow = sims, ncol = length(bites))
for (i in 1:sims){
  rho <- plogis(check$statistics[,"Mean"]["B_tt"]*(1/ttimes) 
                    + rnorm(length(ttimes), mean = 0, sd = check$statistics[,"Mean"]["sd"]))
  p_rabid <- 1/(1 + sqrt(expected.mean*rho)*check$statistics[,"Mean"]["B_norm"])
  bites.sim.low[i, ] <- rpois(length(p_rabid), expected.mean*rho/p_rabid)
}
rankCI <- function(x){
  upper <- x[order(x)][0.95*length(x)]
  lower <- x[order(x)][0.05*length(x)]
  return(c(lower, upper))
}

upper.CI.low <- apply(bites.sim.low, 2, rankCI)[2,]
lower.CI.low <- apply(bites.sim.low, 2, rankCI)[1,]

par(mfrow = c(1, 2))
plot(bites, pch = 1, col = "red", bty = "l", xlab = "w/ Low estimated incidence",
     ylab = "Total bites", axes = FALSE)
axis(2)
points(colMeans(bites.sim.low), col = "darkred", pch = 20)
segments(x0 = 1:length(bites), y0 = lower.CI.low, x1 = 1:length(bites), 
         y1 = upper.CI.low, col = "darkred")

plot(bites, pch = 1, col = "red", bty = "l", xlab = "w/ High estimated incidence",
     ylab = "Total bites",axes = FALSE)
axis(2)
points(colMeans(bites.sim.high), col = "red", pch = 20)
segments(x0 = 1:length(bites), y0 = lower.CI.high, x1 = 1:length(bites), 
         y1 = upper.CI.high, col = "red")
```


## Right now: generating the right functional forms of p_report and p_rabid

```{r getting the right functional forms}

## functional form of p_rabid
par(mfrow = c(1,1))
plot(moramanga$monthly.incidence*12, p_rabid_low, bty = "l", pch = 20, ylim = c(0,1), col = "darkred")
points(moramanga$monthly.incidence*12, p_rabid_high, pch = 20, col = "red")

points(moramanga$monthly.incidence*12, 
       1/(1 + sqrt(exps.per100k.low*moramanga$commune.midpops/1e5)*
                     (moramanga$monthly.incidence*12*p_rabid_low/exps.per100k.low)*10), col = "darkred")

points(moramanga$monthly.incidence*12, 
       1/(1 + sqrt(exps.per100k.high*moramanga$commune.midpops/1e5)*
                     (moramanga$monthly.incidence*12*p_rabid_high/exps.per100k.high)*10), col = "red")

par(mfrow = c(1,1))
plot(plogis(seq(-10, 10, by = 1)), p_rabid_low, bty = "l", pch = 20, ylim = c(0,1), col = "darkred")
points(moramanga$monthly.incidence*12, p_rabid_high, pch = 20, col = "red")

points(moramanga$monthly.incidence*12, 
       1/(1 + sqrt(exps.per100k.low*moramanga$commune.midpops/1e5)*
                     (moramanga$monthly.incidence*12*p_rabid_low/exps.per100k.low)*10), col = "darkred")

points(moramanga$monthly.incidence*12, 
       1/(1 + sqrt(exps.per100k.high*moramanga$commune.midpops/1e5)*
                     (moramanga$monthly.incidence*12*p_rabid_high/exps.per100k.high)*10), col = "red")
```

*Next step would be to clean the data from Madagascar and see if this works with the bigger data set*

*Question to be able to answer*:
What would happen if we thought incidence scaled with population size in this range? Then generally
we would see more conservative estimates of p_report overall.

## GAM 
