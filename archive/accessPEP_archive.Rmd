---
title: "PEP Access"
author: "Malavika Rajeev"
date: "6/25/2018"
output: html_document
---
## Background
Access to PEP is geographically limited in Madagascar, with PEP available in only 31 clinics across the country. Therefore the burden of human rabies deaths is likely concentrated in the areas with the least access. However, these areas are also the areas with the lowest population size, which makes it difficult to distinguish decreases in the incidence of reported bites due to population size (i.e. if incidence increases with population size or alternatively if the dog population increases with population size) vs. access. We are further limited by the fact that the only available data is on reported animal bites (i.e. there are no data available on confirmed/probable rabies exposures or on unreported bites of any kind other than from one district over a period of 16 months, Rajeev et al. 2018) 

Here we attempt to disentagle these factors by estimating the relationship between travel time to a clinic and reporting rates based on assumptions of dog rabies incidence and background levels of non-rabid bites. 

We constrain incidence of human exposures based on estimates of human exposures per 100,000 dogs in a no-vaccination scenario generated by Hampsone et al. 2018. We then set upper and lower bounds on the human:dog ratio (between 5 people per dog to 25 people per dog) to get the maximum and minimum expected annual bites per 100,000 people for each commune.

We then fit a model to our reported bite data (annual reported bites by commune) where bite incidence is predicted by population size. Then we estimate the reporting rate as a function of travel time. 

Then the bites we osberve
bites[j,t] = expected.incidence*reporting + background.bites
expected.incidence = f(pop)
reporting = f(ttime)

So that we get the most conservative estimates of the relationship between reporting and travel times (i.e. taking out the maximum observed impact of pop on incidence)

```{r setup, include=FALSE}
## libraries 
# for gis 
library(raster)
library(maptools)
library(maps)
library(GISTools)
library(rgdal)
library(sp)
library(rgdal)
library(gdistance)
# everything else
library(tidyverse)
library(rjags)
library(coda)
library(lattice)
# pkgs <- c("lattice", "coda")
# require(pkgs, character.only = TRUE)

## data
exposure.mat <- read.csv("data/exposures_by_commune_Moramanga.csv", header = TRUE, row.names = 1)
moramanga <- readOGR("data/MoramangaGIS/MoramangaPops.shp")
ctar.gps <- read.csv("data/ctar_gps.csv")
```


```{r matching to gis file}
## Summary stats
monthly.bites <-rowSums(exposure.mat)/ncol(exposure.mat)
moramanga$commune.midpops <- moramanga$pop2015adj + (moramanga$pop2020adj - moramanga$pop2015adj)/2
moramanga$monthly.bites <- monthly.bites[match(moramanga$commune, names(monthly.bites))]
moramanga$monthly.incidence <- moramanga$monthly.bites/moramanga$commune.midpops*1e5
# distance!

## travel time layer
travel.times <- raster("output/study.area.accessibility.tif")
mora.access <- mask(travel.times, moramanga)
mora.access <- crop(mora.access, moramanga)
moramanga <- raster::extract(mora.access, moramanga, fun = mean, na.rm=TRUE, df = TRUE, sp = TRUE)
moramanga$comm.long <- coordinates(moramanga)[,1]
moramanga$comm.lat <- coordinates(moramanga)[,2]

# plot it
plot(mora.access/60,
     breaks = c(0, 1, 2, 3, 4, 5, 6, 7,8, 16, max(values(mora.access)/60, na.rm = TRUE)),
     col = c("#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", 
             "#ae017e", "#7a0177", "#49006a"), axes = FALSE, box = FALSE)
points(moramanga$comm.long[moramanga$commune == "Moramanga"], moramanga$comm.lat[moramanga$commune == "Moramanga"], pch = 18, col = "grey", cex = 2)

## correlation checks (need to add in distance and proportion of pop within x km/hrs)
cor(moramanga@data[,colnames(moramanga@data) %in% c("commune.midpops", "study.area.accessibility", "monthly.incidence")])
splom(log(moramanga@data[,colnames(moramanga@data) %in% c("commune.midpops", "study.area.accessibility", "monthly.incidence")]), type=c('p','r'))
```

## Empirical estimates of p_report
```{r empirical}
exposures.per100k.dogs.high <- 1000*0.39
exposures.per100k.dogs.low <- 600*0.39

hdr.high <- 25
hdr.low <- 5

expected.exposures.high <- moramanga$commune.midpops/hdr.low/1e5*exposures.per100k.dogs.high # annual bites assuming low HDR and high exposures
expected.exposures.low <- moramanga$commune.midpops/hdr.high/1e5*exposures.per100k.dogs.low # annual bites assuming high HDR and low exposures
expected.exposures.mid <- (expected.exposures.high + expected.exposures.low)/2
# middle of the road estimate of incidence

reported <- moramanga$monthly.bites*12

p_rabid_max_low <- expected.exposures.low/reported*0.9
p_rabid_max_high <- expected.exposures.high/reported*0.9
p_rabid_max_low[p_rabid_max_low >= 1] <- 1
p_rabid_max_high[p_rabid_max_high > 1] <- 1

plot(moramanga$study.area.accessibility, p_rabid_max_low, ylim = c(0, 1), bty = "l", col = "darkblue") 
plot(moramanga$study.area.accessibility, p_rabid_max_high, ylim = c(0, 1), bty = "l", col = "darkblue") 

empirical.reporting <- function (bites, p_rabid = 0.2, expected, samples = 1000) {
    p_rabid_max = expected/bites*0.9
    p_rabid_max[p_rabid_max >= p_rabid] <- p_rabid
    p_report <- rep(NA, length(bites))
    
    for (i in 1:length(bites)){
      reported_rabies <- rpois(samples, bites[i]*p_rabid_max[i])
      expected_rabies <- rpois(samples, expected[i])
      p_reported <- reported_rabies/expected_rabies
      p_report[i] <- mean(p_reported[p_reported != Inf], na.rm = TRUE)
    }
  return(p_report)
}

empirical.reporting.fixed <- function (bites, p_rabid = 0.2, expected) {
    p_rabid_max = expected/bites*0.9
    p_rabid_max[p_rabid_max >= p_rabid] <- p_rabid
    p_report <- bites*p_rabid_max/expected
    return(p_report)
}

plot(moramanga$study.area.accessibility, empirical.reporting.fixed(reported, p_rabid = 0.05, expected.exposures.low),
     ylim = c(0, 1), bty = "l", col = "darkblue") # best case
points(moramanga$study.area.accessibility, empirical.reporting.fixed(reported, p_rabid = 0.9, expected.exposures.low), 
       col = "blue") # worst case
points(moramanga$study.area.accessibility, empirical.reporting.fixed(reported, p_rabid = 0.9, expected.exposures.high), 
       col = "red", pch = 20) # middle of the ground scenario
points(moramanga$study.area.accessibility, empirical.reporting.fixed(reported, p_rabid = 0.05, expected.exposures.high), 
       col = "darkred", pch = 20) # worst case

## expected to observed
plot(expected.exposures.high, moramanga$monthly.bites*12, 
     xlim = c(0, max(expected.exposures.high)), 
     ylim = c(0, max(moramanga$monthly.bites*12)), bty = "l", pch = 20)
abline(a = 0, b = 1)

plot(moramanga$commune.midpops, p_rabid_max_high)
plot(moramanga$study.area.accessibility, p_rabid_max_high)
plot(moramanga$commune.midpops, p_rabid_max_low)
plot(moramanga$study.area.accessibility, p_rabid_max_low)

```


## JAGs model of p_report

```{r jags model}
p_rabid_max_low[p_rabid_max_low > 0.2] <- 0.2
p_rabid_max_high[p_rabid_max_high > 0.2] <- 0.2

mora.bites <- merge(moramanga@data, exposure.mat, by.x = "commune", by.y = "row.names")
bites <- mora.bites[ , 21:36]
ttimes <- mora.bites$study.area.accessibility/60

## model
tt.model <- "model {
  # reported bites
  for (t in 1:ntimes){
    for (j in 1:nlocs){
        # Number of bites
        expected[j, t] ~ dpois(expected.mean[j])
        reported[j, t] ~ dbinom(rho[j], expected[j, t])
        bites[j, t] ~ dpois(reported[j, t]/p_rabid[j] + B_0)
    }
  }

  # spatial effects
  for (g in 1:nlocs){
    # Spatial random effect
    loc_eff[g] ~ dnorm(0, tau_loc)

    # Reporting in place g
    logit(rho[g]) <- B_tt*ttimes[g] + loc_eff[g]
  }

  tau_loc <- 1/sd

  # priors
  B_tt ~ dnorm(0, 0.001)
  sd ~ dunif(0, 100)
  B_0 ~ dnorm(0, 0.001)

}"

## data
ntimes = ncol(bites)
nlocs = nrow(bites)

data <- list (bites = bites, expected.mean = expected.exposures.high/12,
              ttimes = ttimes, ntimes = ntimes , nlocs = nlocs, p_rabid = p_rabid_max_low)

inits <- list(B_tt = rnorm(1, 0, 1e-6), sd = 1, B_0 = rnorm(1, 0, 1e-6))

jags_mod <- jags.model(textConnection(tt.model), data = data, inits = inits, n.chains = 5, n.adapt = 1000)

params <- c("B_tt", "sd", "B_0")

samps <- coda.samples(jags_mod, params, n.iter = 10000)
burn.in <- 5000
summary(window(samps, start = burn.in))
plot(samps)
gelman.plot(samps)
gelman.diag(samps)
```


```{r jags model annual}
bites <- rowSums(mora.bites[ , 21:36])
ttimes <- mora.bites$study.area.accessibility/60

## model
tt.model <- "model {
  # reported bites
    for (j in 1:nlocs){
        # Number of bites
        expected[j] ~ dpois(expected.mean[j])
        reported[j] ~ dbinom(rho[j], expected[j])
        bites[j] ~ dpois(reported[j]/p_rabid[j] + 0.01)
    }
  

  # spatial effects
  for (g in 1:nlocs){
    # Spatial random effect
    loc_eff[g] ~ dnorm(0, tau_loc)

    # Reporting in place g
    logit(rho[g]) <- B_tt*ttimes[g] + loc_eff[g]
  }

  tau_loc <- 1/sd

  # priors
  B_tt ~ dnorm(5, 0.001)
  sd ~ dunif(0, 100)
}"

## data
nlocs = length(bites)

data <- list (bites = bites, expected.mean = expected.exposures.high,
              ttimes = ttimes, nlocs = nlocs, p_rabid = p_rabid_max_high)

inits <- list(B_tt = rnorm(1, 0, 1e-6), sd = 1)

jags_mod <- jags.model(textConnection(tt.model), data = data, inits = inits, n.chains = 5, n.adapt = 1000)

params <- c("B_tt", "sd")

samps <- coda.samples(jags_mod, params, n.iter = 10000)
burn.in <- 5000
summary(window(samps, start = burn.in))
plot(samps)
gelman.plot(samps)
gelman.diag(samps)
```


```{r jags model with incidence scaling with pop}
p_rabid_max_low[p_rabid_max_low > 0.2] <- 0.2
p_rabid_max_high[p_rabid_max_high > 0.2] <- 0.2

mora.bites <- merge(moramanga@data, exposure.mat, by.x = "commune", by.y = "row.names")
bites <- mora.bites[ , 21:36]
ttimes <- mora.bites$study.area.accessibility/60

## model
tt.model <- "model {
  # reported bites
  for (t in 1:ntimes){
    for (j in 1:nlocs){
        # Number of bites
        bites[j, t] ~ dpois(expected.mean[j] + background[j] + 0.01)
    }
  }

  # spatial effects
  for (g in 1:nlocs){
    # Spatial random effect
    loc_eff[g] ~ dnorm(0, tau_loc)

    # Reporting in place g
    logit(rho[g]) <- B_tt*ttimes[g] + loc_eff[g]
    
    # Incidence avg in place g
    expected.inc[g] <- B_pop*pop[g] 
    
    # Background avg in place g
    # Proportion rabid
    log(background[g]) <- B_prop*pop[g]
  }

  tau_loc <- 1/sd

  # priors
  B_tt ~ dnorm(0, 0.001)
  sd ~ dunif(0, 100)
  B_pop ~ dnorm(0, 0.001)
  B_0 ~ dnorm (1, 0.001)
  B_prop ~ dnorm(0, 0.001)
}"

## data
ntimes = ncol(bites)
nlocs = nrow(bites)

data <- list (bites = bites, pop = moramanga$commune.midpops, 
              expected.max = round(expected.exposures.high/12 + 3), 
              ttimes = ttimes, ntimes = ntimes , nlocs = nlocs)

inits <- list(B_tt = rnorm(1, 0, 1e-6), sd = 1, 
              B_pop = rnorm(1, 1, 1e-6), B_0 = rnorm(1, 1, 1e-6), B_prop = rnorm(1, 1, 1e-6))

jags_mod <- jags.model(textConnection(tt.model), data = data, inits = inits, n.chains = 5, n.adapt = 1000)

params <- c("B_tt", "sd", "B_pop", "B_0", "B_prop")

samps <- coda.samples(jags_mod, params, n.iter = 10000)
burn.in <- 5000
summary(window(samps, start = burn.in))
plot(samps)
gelman.plot(samps)
gelman.diag(samps)
```


### Data overall
```{r matching to gis file}
## Summary stats
monthly.bites <-rowSums(exposure.mat)/ncol(exposure.mat)
moramanga$commune.midpops <- moramanga$pop2015adj + (moramanga$pop2020adj - moramanga$pop2015adj)/2
moramanga$monthly.bites <- monthly.bites[match(moramanga$commune, names(monthly.bites))]
moramanga$monthly.incidence <- moramanga$monthly.bites/moramanga$commune.midpops*1e5
# distance!

## travel time layer
travel.times <- raster("output/study.area.accessibility.tif")
mora.access <- mask(travel.times, moramanga)
mora.access <- crop(mora.access, moramanga)
moramanga <- raster::extract(mora.access, moramanga, fun = mean, na.rm=TRUE, df = TRUE, sp = TRUE)
moramanga$comm.long <- coordinates(moramanga)[,1]
moramanga$comm.lat <- coordinates(moramanga)[,2]

# plot it
plot(mora.access/60,
     breaks = c(0, 1, 2, 3, 4, 5, 6, 7,8, 16, max(values(mora.access)/60, na.rm = TRUE)),
     col = c("#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", 
             "#ae017e", "#7a0177", "#49006a"), axes = FALSE, box = FALSE)
points(moramanga$comm.long[moramanga$commune == "Moramanga"], moramanga$comm.lat[moramanga$commune == "Moramanga"], pch = 18, col = "grey", cex = 2)
legend("topright", legend = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 16, max(values(mora.access)/60, na.rm = TRUE)), fill = c("#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", 
             "#ae017e", "#7a0177", "#49006a"))

# correlation checks (need to add in distance and proportion of pop within x km/hrs)
library(GGally)
#kable(cor(moramanga@data[,colnames(moramanga@data) %in% c("commune.midpops", "study.area.accessibility", "monthly.incidence")]))
ggpairs(log(moramanga@data[,colnames(moramanga@data) %in% c("commune.midpops", "study.area.accessibility", "monthly.incidence")]), columnLabels = c("log(Pop)", "log(Travel time)", "log(Monthly Incidence)"))
#splom(log(moramanga@data[,colnames(moramanga@data) %in% c("commune.midpops", "study.area.accessibility", "monthly.incidence")]), type=c('p','r'))
```

## Empirical estimates of p_report
We can empirically calculate estimates of p_report by solving for it at our maximum and minimum estimates of incidence and maximum and minimum estimates of p_rabid to get a range of reporting probabilities for each location (here we set the maximum possible reporting to be 0.95).

```{r empirical}
exposures.per100k.dogs.high <- 1000*0.39
exposures.per100k.dogs.low <- 600*0.39

hdr.high <- 25
hdr.low <- 5

expected.exposures.high <- moramanga$commune.midpops/hdr.low/1e5*exposures.per100k.dogs.high # annual bites assuming low HDR and high exposures
expected.exposures.low <- moramanga$commune.midpops/hdr.high/1e5*exposures.per100k.dogs.low # annual bites assuming high HDR and low exposures
expected.exposures.mid <- (expected.exposures.high + expected.exposures.low)/2
# middle of the road estimate of incidence

reported <- moramanga$monthly.bites*12

p_rabid_max_low <- expected.exposures.low/reported*0.95
p_rabid_max_high <- expected.exposures.high/reported*0.95
p_rabid_max_low[p_rabid_max_low >= 1] <- 1
p_rabid_max_high[p_rabid_max_high > 1] <- 1



par(mfrow = c(1, 1), mar = c(5, 5, 2,  2))
plot(moramanga$study.area.accessibility, empirical.reporting.fixed(reported, p_rabid = 0.05, expected.exposures.low),
     ylim = c(0, 1), bty = "l", col = "darkblue", xlab = "travel time (mi") # best case
plot(moramanga$study.area.accessibility, empirical.reporting.fixed(reported, p_rabid = 0.9, expected.exposures.low), 
       col = "blue") # worst case
plot(moramanga$study.area.accessibility, empirical.reporting.fixed(reported, p_rabid = 0.9, expected.exposures.high), 
       col = "red", pch = 20) # middle of the ground scenario
plot(moramanga$study.area.accessibility, empirical.reporting.fixed(reported, p_rabid = 0.05, expected.exposures.high), 
       col = "darkred", pch = 20) # worst case
# legend("topright", bty = "n", legend = c("Low exposures + low p_rabid", "Low exposures + high p_rabid",
                    # "High exposures + high p_rabid", "High exposures + low p_rabid"),
       # col = c("darkblue", "blue", "red", "darkred"), pch = 20)
```


Here we attempt to disentagle these factors by estimating the relationship between travel time to a clinic and reporting rates based on assumptions of dog rabies incidence and background levels of non-rabid bites. 

We constrain incidence of human exposures based on estimates of human exposures per 100,000 dogs in a no-vaccination scenario generated by Hampson et al. 2018. We then set upper and lower bounds on the human:dog ratio (between 5 people per dog to 25 people per dog) to get the maximum and minimum expected annual bites per 100,000 people for each commune.

We then fit a model to our reported bite data (annual reported bites by commune) where bite incidence is predicted by population size, but only within a plausible range of incidences by estimating a scaling factor of incidence with population size. We also assume that background incidence of reported non-rabid dog bites increase with population size (Hampson et al. 2018, Figure 2). Then we estimate the incidence scaling factor by population size, the relationship between travel time and the reporting rate, and the relationship between population size and the proportion rabid, such that:

```{r Annual jags model with incidence scaling with pop and estimating p_rabid}
## model
tt.model <- "model {
  # reported bites
    for (j in 1:nlocs){
        # Number of bites
        rabid[j] ~ dpois(expected.mean[j])
        reported[j] ~ dbinom(rho[j], rabid[j])
        bites[j] ~ dpois(reported[j] + A[j])
    }
  `
  # spatial effects
  for (g in 1:nlocs){
    # Spatial random effect
    loc_eff[g] ~ dnorm(0, tau_loc)
    pop_eff[g] ~ dnorm(0, tau_pop)

    # Reporting in place g
    logit(rho[g]) <- B_tt*(1/ttimes[g]) + loc_eff[g]
    
    # Background avg in place g
    log(A[g]) <- B_pop*pop[g] + pop_eff[g]
  }

  tau_loc <- 1/sd
  tau_pop <- 1/sd.pop

  # priors
  B_tt ~ dnorm(0, 0.1)
  sd ~ dunif(0, 100)
  sd.pop ~ dunif(0, 100)
  B_pop ~ dnorm(0, 0.1)
  B_0 ~ dnorm(0, 0.1)
}"
```


And we set it so that we get the most conservative estimates of the relationship between reporting and travel times (i.e. taking out the maximum observed impact of pop on incidence)

```{r Data and estimation}
mora.bites <- merge(moramanga@data, exposure.mat, by.x = "commune", by.y = "row.names")
pop <- moramanga$commune.midpops
bites <- round(moramanga$monthly.bites*12)
ttimes <- mora.bites$study.area.accessibility/60
max.sf <- (expected.exposures.high/expected.exposures.mid)[1] # upper constraint of scaling factor
min.sf <- (expected.exposures.low/expected.exposures.mid)[1] # lower constraint of scaling factor
B_pop.max <- min(max.sf/pop)
B_pop.max*pop > max.sf # check to see if max good
B_pop.min <- max(min.sf/pop)
B_pop.min*pop < min.sf # check to see if min is good

## expected to observed
par(mfrow = c(1, 2))
plot(expected.exposures.high, moramanga$monthly.bites*12, col = "red", bty = "l", pch = 20)
lines(expected.exposures.high, expected.exposures.high, col = "red")
plot(expected.exposures.low, moramanga$monthly.bites*12, col = "blue", bty = "l", pch = 20)
lines(expected.exposures.low, expected.exposures.low, col = "blue")

plot(moramanga$commune.midpops, 
     (moramanga$monthly.bites*12)/(expected.exposures.mid*(B_pop.min*moramanga$commune.midpops)), 
      col = "red", bty = "l", pch = 20)
abline(h = 1)
points(moramanga$commune.midpops, 
       moramanga$monthly.bites*12/(expected.exposures.mid*(B_pop.max*moramanga$commune.midpops)), 
       col = "blue", pch = 20)

plot(moramanga$study.area.accessibility/60, 
     (moramanga$monthly.bites*12)/(expected.exposures.mid*(B_pop.min*moramanga$commune.midpops)), 
      col = "red", bty = "l", pch = 20)
abline(h = 1)
points(moramanga$study.area.accessibility/60, 
       moramanga$monthly.bites*12/(expected.exposures.mid*(B_pop.max*moramanga$commune.midpops)), 
       col = "blue", pch = 20)

## maximums 
plot(moramanga$commune.midpops, p_rabid_max_high, bty = "l", pch = 20, 
     ylim = c(0,1), col = "blue") # low incidence
points(moramanga$commune.midpops, p_rabid_max_low, col = "red", pch = 20) # high incidence
```

```{r Estimation}
## potential relationship between reporting and travelt
## data
nlocs = length(bites)

data <- list (bites = bites, pop = moramanga$commune.midpops, 
              expected.mean = expected.exposures.mid,
              ttimes = ttimes, nlocs = nlocs)

inits <- list(B_tt = rnorm(1, 0, 1e-6), sd = 5, sd.pop = 5,
              B_pop = rnorm(1, 0, 1e-6))

jags_mod <- jags.model(textConnection(tt.model), data = data, inits = inits, n.chains = 5, 
                       n.adapt = 1000)

params <- c("B_tt", "sd", "B_pop", "sd.pop")

samps <- coda.samples(jags_mod, params, n.iter = 10000)
burn.in <- 5000
check <- summary(window(samps, start = burn.in))
check
plot(samps)
# gelman.plot(samps)
gelman.diag(samps)

## parameter estimates
par(mfrow = c(2, 2), mar = c(5, 5, 2,  2))
plot(pop, rpois(length(bites), exp(check$statistics[,"Mean"]["B_pop"]*pop))
      + rnorm(length(ttimes), mean = 0, sd = check$statistics[,"Mean"]["sd.pop"]), bty = "l")
plot(pop, plogis(check$statistics[,"Mean"]["B_prop"]*pop), bty = "l")
plot(ttimes, plogis(check$statistics[,"Mean"]["B_tt"]*(1/ttimes)), bty = "l")
plot(ttimes, plogis(check$statistics[,"Mean"]["B_tt"]*(1/ttimes) 
                    + rnorm(length(ttimes), mean = 0, sd = check$statistics[,"Mean"]["sd"])),
     bty = "l")

```

The scaling factor is not identifiable.

### Fixing at minimum scaling factor

```{r Fixing at minimum scaling of inc w/ pop and estimating other params}
## model
tt.model <- "model {
  # reported bites
    for (j in 1:nlocs){
        # Number of bites
        bites[j] ~ dpois(rabid[j]*rho[j] + background[j] + B_0)
    }
  
  # spatial effects
  for (g in 1:nlocs){
    # Spatial random effect
    loc_eff[g] ~ dnorm(0, tau_loc)

    # Reporting in place g
    logit(rho[g]) <- B_tt*(1/ttimes[g]) + loc_eff[g]
    
    # Incidence avg in place g
    scaling.factor[g] <- B_pop*pop[g]
    rabid[g] <- scaling.factor[g]*expected.mean[g]
    
    # Background avg in place g
    logit(p_rabid[g]) <- B_prop*pop[g]
    background[g] <- (rabid[g]*rho[g])/p_rabid[g] - rabid[g]
  }

  tau_loc <- 1/sd

  # priors
  B_tt ~ dnorm(0, 0.1)
  sd ~ dunif(0, 100)
  B_prop ~ dnorm(0, 0.1)
  B_0 ~ dnorm(0, 0.1)
}"

## data
nlocs = length(bites)

data <- list (bites = bites, pop = moramanga$commune.midpops, 
              expected.mean = expected.exposures.mid,
              B_pop = B_pop.min, ttimes = ttimes, nlocs = nlocs)

inits <- list(B_tt = rnorm(1, 0, 1e-6), sd = 5, 
              B_prop = rnorm(1, 0, 1e-6), 
              B_0 = rnorm(1, 0, 1e-6))

jags_mod <- jags.model(textConnection(tt.model), data = data, inits = inits, n.chains = 5, 
                       n.adapt = 1000)

params <- c("B_tt", "sd", "B_prop", "B_0")

samps <- coda.samples(jags_mod, params, n.iter = 10000)
burn.in <- 5000
summary(window(samps, start = burn.in))
plot(samps)
# gelman.plot(samps)
gelman.diag(samps)

samps <- coda.samples(jags_mod, params, n.iter = 10000)
burn.in <- 5000
check <- summary(window(samps, start = burn.in))
check
plot(samps)
# gelman.plot(samps)
gelman.diag(samps)

## parameter estimates
par(mfrow = c(1, 1), mar = c(5, 5, 2,  2))
plot(pop, (B_pop.min*pop*expected.exposures.mid)/(pop/1e5), bty = "l")
plot(pop, plogis(check$statistics[,"Mean"]["B_prop"]*pop), bty = "l")
plot(ttimes, plogis(check$statistics[,"Mean"]["B_tt"]*(1/ttimes)), bty = "l")
plot(ttimes, plogis(check$statistics[,"Mean"]["B_tt"]*(1/ttimes) + rnorm(length(ttimes), mean = 0, sd = check$statistics[,"Mean"]["sd"])), bty = "l")
```

### Fixing at maximum scaling factor

```{r Fixing at maximum scaling of inc w/ pop and estimating other params}
## model
tt.model <- "model {
  # reported bites
    for (j in 1:nlocs){
        # Number of bites
        bites[j] ~ dpois(rabid[j]*rho[j] + background[j] + B_0)
    }
  
  # spatial effects
  for (g in 1:nlocs){
    # Spatial random effect
    loc_eff[g] ~ dnorm(0, tau_loc)

    # Reporting in place g
    logit(rho[g]) <- B_tt*(1/ttimes[g]) + loc_eff[g]
    
    # Incidence avg in place g
    scaling.factor[g] <- B_pop*pop[g]
    rabid[g] <- scaling.factor[g]*expected.mean[g]
    
    # Background avg in place g
    logit(p_rabid[g]) <- B_prop*pop[g]
    background[g] <- (rabid[g]*rho[g])/p_rabid[g] - rabid[g]
  }

  tau_loc <- 1/sd

  # priors
  B_tt ~ dnorm(0, 0.1)
  sd ~ dunif(0, 100)
  B_prop ~ dnorm(0, 0.1)
  B_0 ~ dnorm(0, 0.1)
}"

## data
nlocs = length(bites)

data <- list (bites = bites, pop = moramanga$commune.midpops, 
              expected.mean = expected.exposures.mid,
              B_pop = B_pop.max, ttimes = ttimes, nlocs = nlocs)

inits <- list(B_tt = rnorm(1, 0, 1e-6), sd = 5, 
              B_prop = rnorm(1, 0, 1e-6), 
              B_0 = rnorm(1, 0, 1e-6))

jags_mod <- jags.model(textConnection(tt.model), data = data, inits = inits, n.chains = 5, 
                       n.adapt = 1000)

params <- c("B_tt", "sd", "B_prop", "B_0")

samps <- coda.samples(jags_mod, params, n.iter = 10000)
burn.in <- 5000
summary(window(samps, start = burn.in))
plot(samps)
# gelman.plot(samps)
gelman.diag(samps)

samps <- coda.samples(jags_mod, params, n.iter = 10000)
burn.in <- 5000
check <- summary(window(samps, start = burn.in))
check
plot(samps)
# gelman.plot(samps)
gelman.diag(samps)

## parameter estimates
par(mfrow = c(2, 2), mar = c(4, 6, 2, 6))
plot(pop, (B_pop.max*pop*expected.exposures.mid)/(pop/1e5), bty = "l")
plot(pop, plogis(check$statistics[,"Mean"]["B_prop"]*pop), bty = "l")
plot(ttimes, plogis(check$statistics[,"Mean"]["B_tt"]*(1/ttimes)), bty = "l")
plot(ttimes, plogis(check$statistics[,"Mean"]["B_tt"]*(1/ttimes) + rnorm(length(ttimes), mean = 0, 
                              sd = check$statistics[,"Mean"]["sd"])), bty = "l")
```


```{r jags model with incidence scaling with pop and fixed p_rabid}
# ## model
# tt.model <- "model {
#   # reported bites
#   for (t in 1:ntimes){
#     for (j in 1:nlocs){
#         # Number of bites
#         bites[j, t] ~ dpois(rabid[j]*rho[j] + background[j] + B_0)
#     }
#   }
# 
#   # spatial effects
#   for (g in 1:nlocs){
#     # Spatial random effect
#     loc_eff[g] ~ dnorm(0, tau_loc)
# 
#     # Reporting in place g
#     logit(rho[g]) <- B_tt*(1/ttimes[g]) + loc_eff[g]
# 
#     # Incidence avg in place g
#     scaling.factor[g] <- B_pop*pop[g]
#     rabid[g] <- scaling.factor[g]*expected.mean[g]
#     
#     # Background avg in place g
#     p_rabid[g] <- ifelse(rabid[g]/avg.reported[g]*0.9 >= p_rabid_max,
#                               p_rabid_max, rabid[g]/avg.reported[g]*0.9)
#     background[g] <- rabid[g]/p_rabid[g] - rabid[g]
#   }
# 
#   tau_loc <- 1/sd
# 
#   # priors
#   B_tt ~ dnorm(0, 0.01)
#   sd ~ dunif(0, 100)
#   B_pop ~ dunif(B_pop.min, B_pop.max)
#   B_0 ~ dnorm(0, 0.01)
# }"

# ## data
# ntimes = ncol(bites)
# nlocs = nrow(bites)
# 
# data <- list (bites = bites, pop = moramanga$commune.midpops, 
#               expected.mean = expected.exposures.mid, avg.reported = moramanga$monthly.bites,
#               p_rabid_max = 0.9, B_pop.min = B_pop.min, B_pop.max = B_pop.max,
#               ttimes = ttimes, ntimes = ntimes , nlocs = nlocs)
# 
# inits <- list(B_tt = rnorm(1, 0, 1e-6), sd = 1, 
#               B_pop = rnorm(1, (B_pop.max + B_pop.min)/2, 1e-6))
# 
# jags_mod <- jags.model(textConnection(tt.model), data = data, inits = inits, n.chains = 10, n.adapt = 1000)
# 
# params <- c("B_tt", "sd", "B_pop")
# 
# samps <- coda.samples(jags_mod, params, n.iter = 10000)
# burn.in <- 5000
# summary(window(samps, start = burn.in))
# plot(samps)
# gelman.plot(samps)
# gelman.diag(samps)
```
