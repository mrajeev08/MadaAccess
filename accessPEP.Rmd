---
title: "Estimating Access to Rabies Post-Exposure Prophylaxis in Madagascar"
author: ""
date: 
output:
  html_document: default
  pdf_document:
    includes:
      in_header: mystyle.sty
  word_document:
    reference_docx: format_docs/word_styles_reference_01.docx
css: style.css
---


## INTRODUCTION

[Start broadly with inequity?]
Inequities in access to healthcare and interventions are a major driver of the burden of disease in human populations. Those most impacted by infectious disease are often those from lower socioeconomic strata and remote populations. Despite the impact of these inequities in shaping disease burden, incorporating these factors into estimations of burden is challenging due to the lack of data resolved to these levels...>
  
<br>

Canine rabies causes an estimated 59,000 human deaths annually. Post-exposure prophylaxis (PEP) prevents fatalities if delivered in a timely manner, however, access to this intervention is highly limited in areas where the disease is endemic. Data on true rabies exposures in humans and incidence in animals is also lacking in most countries. Often, the only data available are numbers of bite victims reporting to health facilities. The majority of rabies burden studies use these data to estimate burden of rabies from probability decision tree frameworks, often with the key assumptions that overall reported bite incidence (i.e. both bites due to non-rabid and rabid animals) are proportional to rabies incidence and that reporting is uniform across space. 

The most recent estimation of burden and the impact of PEP used another approach, using transmission dynamic models as the backbone to predict incidence based on level of vaccination coverage and size of the dog population at the national level. Using transmission dynamic models to estimate incidence could improve upon previous studies which may overestimate rabies burden in areas of high reporting and underestimate in areas with low reporting due to the assumption that overall reported bite incidence is proportional to rabies incidence.

<br>

Here, we extend this framework to include spatial access to PEP, using bite patient data from 27 clinics in Madagascar, a rabies endemic country that lacks a national strategy for controlling rabies in domestic dogs. Institut Pasteur de Madagascar (IPM) provides PEP at no-cost to the government or to patients that present to 31 clinics across the country. PEP is not available at any other public clinics or through the private sector. Given that rabies is endemic in the country and there is effectively no vaccination of domestic dogs, we use the baseline predictions of incidence from the dynamic model reported in Hampson et al. 2018. We flip the standard decision tree and make the assumption that reported bite incidence reflects access and reporting to PEP rather than differences in rabies incidence, using travel times to clinics as a predictor of bites reported to clinics.

## METHODS

### Bite patient data
We used the database of bite patient forms submitted from 24 ARMC between 2014 - 2017. These were individual patient data forms that were submitted to IPM as frequently as monthly to annually by clinics. Two clinics, the IPM ARMC and the Fianarantsoa ARMC used computer databases from which the data during this period were extracted and merged to the larger database. These data include the administrative district of the bite patient's address. As previous analyses showed likely substantial undersubmission of forms from clinics (*cite baseline data paper*), we calculated the proportion of days of the year for which forms were submitted. We excluded periods with 10 or more consecutive dates with no patient forms and calculated the proportion of days included per year. Figure 1a + 1b?

RIG data?

<br>

### GIS Data
We use the global friction surface for 2015 generated by the Malaria Atlas Project ( https://map.ox.ac.uk/research-project/accessibility_to_cities/, Weiss et al. 2015,) and GPS points of clinics to get travel time to the nearest ARMC for the country of Madagascar at a 1 x 1 km scale. We then averaged these to the commune level, using administrative shapefiles available trhough the UN Office for the Coordination of Humanitarian Affairs. For each clinic, we defined the catchment area as all communes for which the clinic was the closest ARMC. Population estimates were taken from the 2015 UN adjusted population projections from World Pop (www.worldpop.org, Linaird et al. 2012) and also aggreagated to the commune level. Figure 2 = networky fig + catchments!

<br>

### Model of reported bites as a function of travel time
Excluding any catchments for which there was less than 25% estimated form submission, we calculated the average bite incidence corrected by the annual undersubmission of forms at the district level.

We fit a linear mixed effects model where the annual average bite incidence at the district level was predicted by the average travel time to the nearest CTAR for the district, the population within the district, and a random catchment level effect.

For three other catchments with reporting above x% we used to out-of-fit predict...
Ability to predict average annual/monthly bite incidence by travel time
Ability to predict out-of-fit to other catchments 

<br>

### Estimation of burden and reporting 
We used our model to predict average annual bite incidence for all 114 districts in Madagascar, and estimated deaths due to rabies given this and assumptions about rabies exposures.

We calculated deaths as:
$$deaths_{i} = (R_{i} - ({p_{rabid} \times B_{i})) \times p_{death}$$

where the proportion of reported bites that are rabies exposures ($p_{rabid}$) are defined as:
$$
           p_{rabid}=
            \begin{cases}
            x, & \text{if}\ \frac{R_i \times \rho_{max}}{B_i} > x \\
            \frac{R_i}{B_i}, & \text{otherwise}
            \end{cases}
$$
<br>

such that rabid reported bites (i.e. $p_{rabid}\timesB_{i}$) cannot exceed the expected number of human exposures given maximum reporting (i.e. $R_{i} \times \rho_{max}$. $p_{rabid}$ is taken from Rajeev et al. 2018 on contact tracing data from the Moramanga District. 

$R_{i}$ is drawn from a uniform distribution between the minimum and maximum expected number of human exposures. We calculate this as:
    
<br>

$$r \times D \times p_{exp}$$ 
    
<br>

where $r$ is rabies incidence in dogs in the absence of any vaccination multiplied by the estimated dog population in the commune ($D_i$) and the exposure rate per rabid dogs ($p_{exp}$ = 0.39 persons exposed per rabid dog)(Hampson et al. 2018). We estimate the dog population by using a human:dog ratio of 5 to generate our maximum expected incidence and an HDR of 25 for our minimum expected incidence. As there is little data on dog populations in Madagascar, this range of HDRs encompasses a wide range observed across Africa(cite?). 
  
<br>

## Estimating the impact of expanding PEP Access
We use this framework to compare three scenarios of PEP provisioning in Madagascar:
1. The baseline with the current clinic locations (n = 31)
2. Expansion of ARMC to one clinic per district (n = 114)
3. Expansion of ARMC to all CSB IIs (n = ...?)

We use data on the location of **CSBs** provided by IPM to regenerate travel times to the nearest ARMC given expansion as per scenario 2 and 3. We then predict the expected bite incidence from the model given these new travel times and compare the relative decreases in burden for the three scenarios.

<br>

### Sensitivity Analyses
- Sensitivity to assumptions of R
- Sensitivity to assumptions of p_rabid

## Preliminary data processing
```{r directory, echo = FALSE, message = FALSE, warning = FALSE, results = 'hide'}
rm(list = ls())
library(knitr)
library(RImagePalette)
library(jpeg)
library(tidyverse)
library(lubridate)
library(magrittr)
library(rgdal)
library(broom)
knitr::opts_chunk$set(fig.pos = 'h', echo = FALSE, message = FALSE, warning = FALSE, results = 'hide')

```

### Data
```{r get data}
## read in data
ctar_data <- read.csv("data/SaisieRage_DATA_2018-09-21_1755.csv")
ctar_metadata <- read.csv("data/ctar_metadata.csv")
mada_district <- readOGR("data/MadaGIS/MadaPops.shp")
dist_catchments <- read.csv("output/catchments_district_unmasked.csv", row.names = 1)
names(dist_catchments) <- c("mdg_dis_co", "CTAR", "ttimes_weighted")

## Centers with no data
no_data <- c("IPM", "Fianarantsoa", "Ambatomainty", "Ambovombe Androy",
             "Antsiranana", "Mandritsara", "Marolambo", "Nosy be", "Sainte Marie",
             "Taolagnaro", "Tsiroanomandidy", "Vangaindrano")
ctar_metadata$exclude <- 0
ctar_metadata$exclude[ctar_metadata$CTAR %in% no_data] <- 1

## Get color palette from other network fig!
img <- readJPEG("~/Downloads/Dp0j4GNUwAAPPJV.jpeg")
pal <- image_palette(img, 31)
add.alpha <- function(col, alpha=1){
  if(missing(col))
    stop("Please provide a vector of colours.")
  apply(sapply(col, col2rgb)/255, 2, 
                     function(x) 
                       rgb(x[1], x[2], x[3], alpha=alpha))  
}
ctar_metadata$color <- c("#FCC56F","#FFDBE5", "#7A4900", "#CBCDD2", "#0000A6", "#EFF2F1",
                 "#63FFAC", "#B79762", "#004D43", "#8FB0FF", "#997D87", "#FD9C54", "#8362B5",
                 "#578FB0","#5A0007", "#809693", "#D16100", "#1B4400", "#4FC601", "#3B5DFF", 
                 "#4A3B53", "#FF2F80","#61615A", "#BA0900", "#6B7900", "#00C2A0", "#FFAA92",
                 "#FF90C9", "#B903AA", "#FEFFE6", "#E9E9D2")
ctar_metadata$fill <- ctar_metadata$color
ctar_metadata$fill[ctar_metadata$CTAR %in% no_data] <- "#D3D3D3"
ctar_metadata$fill <- add.alpha(ctar_metadata$fill, 0.25)
ctar_metadata$ctar_dist <- mada_district$mdg_dis_co[match(ctar_metadata$District, 
                                                           mada_district$district)]
display_palette(ctar_metadata$color)
dist_catchments %>% left_join(select(ctar_metadata, CTAR, exclude, 
                                     color, fill, ctar_dist, LATITUDE, LONGITUDE)) -> dist_catchments
mada_district@data <- left_join(mada_district@data, dist_catchments)
```

```{r catchment figure}
## get exposure matrix
ctar_data %>% 
  group_by(district, id_ctar) %>% # group by district and ctar
  summarize(n = n()) -> exp_mat # get count of exposures
dist_points <- cbind(select(mada_district@data,
                            mdg_dis_co), coordinates(mada_district))
names(dist_points)[2:3] <- c("dist_long", "dist_lat")
dist_points %>%
 left_join(select(ctar_metadata, ctar_dist, LATITUDE, LONGITUDE), 
           by = c("mdg_dis_co" = "ctar_dist")) %>%
 mutate(dist_long = coalesce(dist_long, LONGITUDE), 
        dist_lat = coalesce(dist_lat, LATITUDE)) -> dist_points

exp_mat %>% 
  left_join(select(dist_points, mdg_dis_co, dist_long, dist_lat), 
            by = c("district" = "mdg_dis_co")) %>%
  left_join(select(ctar_metadata, id_ctar, LATITUDE, LONGITUDE,
                   color, fill, ctar_dist)) -> dist_lines
dist_lines$size <- log(dist_lines$n + 0.1)*0.2

ctar_data %>%
  group_by(district) %>%
  summarize(n = n()) %>%
  right_join(select(dist_points, mdg_dis_co, dist_long, dist_lat),
             by = c("district" = "mdg_dis_co")) %>%
  left_join(dist_catchments, by = c("district" = "mdg_dis_co") ) -> dist_points
dist_points$size <- log(dist_points$n + 0.1)*0.25


pdf("figs/network.pdf")
plot(mada_district, col = mada_district$fill, border = "grey") 
points(dist_points$dist_long, dist_points$dist_lat, pch = 20, cex = dist_points$size, 
       col = dist_points$color)
segments(dist_lines$LONGITUDE, dist_lines$LATITUDE, x1 = dist_lines$dist_long, y1 = dist_lines$dist_lat, 
         lwd = dist_lines$size*2, col = dist_lines$color)
dev.off()

legend("topleft", c(">100", ">200", ">400", ">800"), title = "Number of total reported bites", 
       text.width = 3, pt.cex = circle_size, col = "grey",  pch = 16, inset = c(0.1, 0.1), lwd = 1.5, bty = "n", xpd = TRUE, y.intersp=2)

exp_mat %>% 
  left_join(select(ctar_metadata, CTAR, id_ctar)) %>%
  left_join(select(dist_catchments, mdg_dis_co, CTAR, exclude), by = c("district" = "mdg_dis_co")) %>%
  group_by(district) %>%
  mutate(prop = n/sum(n),
         catch_match = ifelse(CTAR.x == CTAR.y, 1, 0)) -> catch_check
ggplot(data = catch_check, aes(CTAR.x, district)) + 
  geom_tile(aes(fill = prop)) +
  scale_fill_continuous(type = "viridis", name = "proportion") +
  geom_text(label = catch_check$catch_match)
```

```{r}
## get vials delivered
ctar_metadata %>% 
  dplyr::select(id_ctar, starts_with("doses")) %>%
  gather(year, vials_delivered, -id_ctar) %>%
  mutate(year = as.numeric(substr(as.character(year), 7, 10))) -> vials_delivered

## getting dose time series by clinic
########### Need to fix dates first! ###############
ctar_data %>%
  select(id_ctar, datej0, datej3, datej7, datej28) %>%
  mutate_at(vars(starts_with("date")), funs(ymd(.))) %>%
  gather(dose, date, -id_ctar) %>%
  group_by(id_ctar, date) %>%
  summarise(n = n()) -> dose_ts
dose_ts <- dose_ts[!is.na(dose_ts$date), ]
dose_ts$ctar <- ctar_metadata$CTAR[match(dose_ts$id_ctar, ctar_metadata$id_ctar)]
dose_ts <- dose_ts[!is.na(dose_ts$ctar), ]

## getting theoretical # vials by year
dose_ts %>%
  mutate(year = year(date), vials = ceiling(n/2)) %>%
  group_by(id_ctar, year) %>%
  summarize(vials_estimated = sum(vials)) %>%
  left_join(vials_delivered) -> dose_comp

######### Patient time series
ctar_data %>%
  select(id_ctar, date_de_consultation) %>%
  mutate(date_de_consultation = ymd(date_de_consultation)) %>%
  gather(dose, date_de_consultation, -id_ctar) %>%
  group_by(id_ctar, date_de_consultation) %>%
  summarise(n = n()) -> patient_ts
patient_ts <- patient_ts[!is.na(patient_ts$date_de_consultation), ]
patient_ts$ctar <- ctar_metadata$CTAR[match(patient_ts$id_ctar, ctar_metadata$id_ctar)]
patient_ts <- patient_ts[!is.na(patient_ts$ctar), ]

ggplot(data = patient_ts, aes(date_de_consultation, ctar)) + 
  geom_tile(aes(fill = n)) +
  scale_fill_continuous(type = "viridis", name = "Patients") 

## getting reporting
start_date <- ymd("2014-01-01")
end_date <- ymd("2017-12-31")
ts <- as_tibble(seq(start_date, end_date, by = "day"))

patient_ts %>%
  right_join(ts, by = c("date_de_consultation" = "value")) %>%
  select(id_ctar, date_de_consultation, n) %>%
  spread(id_ctar, n) %>%
  replace(., is.na(.), 0) -> doses_wide
dose_mat <- as.matrix(doses_wide[, 2:(ncol(doses_wide) - 1)])

date_mat <- matrix(NA, nrow(dose_mat), ncol(dose_mat))
for (j in 1:ncol(date_mat)){
  rle(dose_mat[ , j]) %>%
    unclass() %>%
    as.data.frame() %>%
    mutate(end = cumsum(lengths),
         start = c(1, lag(end)[-1] + 1)) %>%
    filter(values == 0, lengths >= 10) -> rles
  for (i in 1:nrow(rles)){
    date_mat[rles$start[i]:rles$end[i], j] <- 0
  }
}

date_mat <- replace(date_mat, is.na(date_mat), 1)
date_mat %>% 
  as_tibble() %>%
  group_by(date = year(doses_wide$date_de_consultation)) %>%
  summarise_all(funs(sum(.)/n())) -> clinic_reporting
colnames(clinic_reporting) <- colnames(doses_wide)[1:(ncol(doses_wide)-1)]
clinic_reporting <- gather(clinic_reporting, id_ctar, prop, -date_de_consultation)
clinic_reporting$ctar <- ctar_metadata$CTAR[match(clinic_reporting$id_ctar, 
                                                  ctar_metadata$id_ctar)]
clinic_reporting$id_ctar <- as.numeric(clinic_reporting$id_ctar)

ggplot(clinic_reporting, aes(x = date_de_consultation, y = ctar, fill = prop)) + 
  geom_tile() +
  scale_fill_gradient(low = "white", high = "blue")
```



## Submission of forms
- Missingness seems to have been due to periods of time without form submission
- Calculating periods of time 

```{r clean data}
## districts that are non-reporter and data not available yet CTAR
mada_district@data %>%
select(district = mdg_dis_co, pop = pop2015adj, ttimes_weighted, CTAR, exclude) -> covars

to_exclude <- c(grep("contact", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("contam", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("consom", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("passage", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE))
to_exclude <- to_exclude[-grep("date", to_exclude, ignore.case = TRUE)]
ctar_data$excl <- 0
ctar_data$excl[ctar_data$remarque %in% to_exclude] <- 1

ctar_data %>% 
  filter(excl != 1) %>% # exclude contacts
  mutate_at(vars(starts_with("date")), funs(ymd(.))) %>% # format dates
  group_by(year = year(date_de_consultation), district, id_ctar) %>% # group by year and district
  summarize(n = n()) -> exposures # get count of exposures

exposures %>%
  rename(date = year) %>%
  left_join(covars) %>% # add pop + ttimes + reporting
  left_join(clinic_reporting) %>%   # add reporting by clinic + year
  filter(exclude == 0, prop > 0.25) %>%
  group_by(district, date) %>%
  mutate(bites = n/prop) %>%
  summarise(bites = sum(bites, na.rm = TRUE)) -> exps_cleaned 
exps_cleaned %>%
  group_by(district) %>%
  summarise(bites = mean(bites)) %>%
  left_join(covars) -> exps_cleaned

library(lme4)

## poisson with total pop as offset
mod <- glm(round(bites) ~ ttimes_weighted + offset(log(round(pop))), 
                 data = exps_cleaned, family = poisson)
plot(exps_cleaned$bites, predict(mod, type = "response"))
plot(exps_cleaned$ttimes_weighted, predict(mod, type = "response"))

```


```{r}
get.burden <- function(covs = covars, pop = covars$pop, model = mod,
                       p_rabid = 0.5, rho_max = 0.9,
                       max_HDR = 25, min_HDR = 5, 
                       dog_rabies_inc = 0.01, human_exp_rate = 0.39, 
                       prob_death = 0.16, nsims = 1000) {
  store_deaths <- store_p_rabid <- matrix(NA, nrow(covs), nsims)

  for (i in 1:nsims) {
    mean_bites <- predict(model, type = "response", newdata = covs)
    bites <- rpois(length(mean_bites), mean_bites)
    mean_exps <- runif(length(pop), min = human_exp_rate*dog_rabies_inc*pop/max_HDR, 
                    max = human_exp_rate*dog_rabies_inc*pop/min_HDR)
    rabid_exps <- rpois(length(mean_bites), mean_exps)
    p_rabid_t <- ifelse(bites*p_rabid/rabid_exps > rho_max, (rho_max*rabid_exps)/bites, p_rabid)
    deaths <- rbinom(length(mean_bites), rabid_exps - round(bites*p_rabid_t), prob_death)
    store_deaths[, i] <- deaths
    store_p_rabid[, i] <- p_rabid_t
  }
  results <- cbind(get.meanCI(store_deaths), get.meanCI(store_p_rabid))
  colnames(results) <- c("deaths_mean", "deaths_lowerCI", "deaths_upperCI",
                         "p_rabid_mean", "p_rabid_lowerCI", "p_rabid_upperCI")
  results <- cbind(covars, results)
  return(results)
}

get.burden.flat <- function(covs = covars, pop = covars$pop, model = mod,
                       p_rabid = 0.5, rho = 0.85, 
                       prob_death = 0.16, nsims = 1000) {
  store_deaths <- matrix(NA, nrow(covs), nsims)

  for (i in 1:nsims) {
    mean_bites <- predict(model, type = "response", newdata = covs)
    bites <- rpois(length(mean_bites), mean_bites)
    unreported <- bites*p_rabid/rho - bites*p_rabid
    deaths <- rbinom(length(mean_bites), round(unreported), prob_death)
    store_deaths[, i] <- deaths
  }
  results <- get.meanCI(store_deaths)
  colnames(results) <- c("deaths_mean", "death_lowerCI", "deaths_upperCI")
  results <- cbind(covars, results)
  return(results)
}


get.meanCI <- function(matrix_by_row, nboots = 1000) {
    mean_rows <- apply(matrix_by_row, 1, mean)
    CIs <- apply(matrix_by_row, 1, boots, nboot = nboots)
    lower <- unlist(CIs)[1, ] 
    upper <- unlist(CIs)[2, ]
    summ <- cbind(mean_rows, lower, upper)
    colnames(summ) <- c("mean", "lower", "upper")
    return(summ)
}

boots <- function(x, nboot = 1000){
  n = length(x)
  xbar = mean(x)
  tmpdata = sample(x,n*nboot, replace=TRUE)
  bootstrapsample = matrix(tmpdata, nrow=n, ncol=nboot)
  bsmeans = colMeans(bootstrapsample)
  deltastar = bsmeans - xbar
  d = quantile(deltastar, c(0.05, 0.95))
  ## Get from quantiles
  ci = xbar - c(d[2], d[1])

  ## Sorted CIs
  sorteddeltastar = sort(deltastar)
  # # Look at the sorted results
  # Find the .05 and .95 critical values of deltastar
  d9alt = sorteddeltastar[5]
  d1alt = sorteddeltastar[950]
  # Find and print the 80% confidence interval for the mean
  ciAlt = xbar - c(d1alt,d9alt)
  # cat(’Alternative confidence interval: ’,ciAlt, ’\n’)
  return(ci)
}

```

```{r}
results_pr20 <- get.burden(p_rabid = 0.20, rho_max = 0.98)
results_pr60 <- get.burden(p_rabid = 0.60,rho_max = 0.98)

plot(results_pr20$ttimes_weighted/60, results_pr20$deaths_mean, col = "darkred", pch = 20)
points(results_pr60$ttimes_weighted/60, results_pr60$deaths_mean, col = "red", pch = 1)
segments(x0 = results_pr60$ttimes_weighted/60, x1 = results_pr60$ttimes_weighted/60,
         y0 = results_pr60$deaths_mean, y1 = results_pr20$deaths_mean, col = "red")


results_pr20 <- get.burden(p_rabid = 0.20, rho_max = 0.90)
results_pr60 <- get.burden(p_rabid = 0.20, rho_max = 0.99)

plot(results_pr20$ttimes_weighted/60, results_pr20$deaths_mean, col = "darkred", pch = 20)
points(results_pr60$ttimes_weighted/60, results_pr60$deaths_mean, col = "red", pch = 1)
segments(x0 = results_pr60$ttimes_weighted/60, x1 = results_pr60$ttimes_weighted/60,
         y0 = results_pr60$deaths_mean, y1 = results_pr20$deaths_mean, col = "red")


results_pr20 <- get.burden(p_rabid = 0.60, rho_max = 0.90)
results_pr60 <- get.burden(p_rabid = 0.60, rho_max = 0.99)

plot(results_pr20$ttimes_weighted/60, results_pr20$deaths_mean, col = "darkred", pch = 20)
points(results_pr60$ttimes_weighted/60, results_pr60$deaths_mean, col = "red", pch = 1)
segments(x0 = results_pr60$ttimes_weighted/60, x1 = results_pr60$ttimes_weighted/60,
         y0 = results_pr60$deaths_mean, y1 = results_pr20$deaths_mean, col = "red")
```

```{r}
exps_cleaned %$% plot(ttimes_weighted, bites)

exps_cleaned %>%
  filter(exclude == 0) %$% 
  plot(ttimes_weighted, incidence, bty = 
                        "n", pch = 20)

mada_dist_gg <- tidy(mada_district, region = "mdg_dis_co")
mada_dist_gg <- left_join(mada_dist_gg, exps_cleaned, by = c("id" = "district"))

ggplot() +
  geom_polygon(data = mada_dist_gg, aes(x = long, y = lat, group = group, fill = CTAR)) +
  scale_colour_viridis_d()

geom_point(data = ctar_metadata, aes (x = LONGITUDE, y = LATITUDE))
ggplot() +
  geom_polygon(data = mada_dist_gg, aes(x = long, y = lat, group = group, fill = ttimes_weighted)) +
  scale_fill_continuous(type = "viridis") +
  geom_point(data = ctar_metadata, aes (x = LONGITUDE, y = LATITUDE))

```
