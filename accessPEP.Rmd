---
title: "Estimating Access to Rabies Post-Exposure Prophylaxis in Madagascar"
author: ""
date: 
output:
  html_document: default
  pdf_document:
    includes:
      in_header: mystyle.sty
  word_document:
    reference_docx: format_docs/word_styles_reference_01.docx
css: style.css
---
## Goals
- To estimate burden of rabies in Madagascar using nationally available data from clinics that provide PEP.
- To explore the potential impacts of expanded access to PEP

## Data
- Patient data from 19 ARMC accross the country over four years (2013 - 2017)
  - includes dates and home locations (to the district level) of patient reporting for PEP
- Patient data from Moramanga ARMC over 28 months (Sep 2016 - Dec 2018)
  - includes dates and home locations (to the commune level) of patients reporting for PEP
  - also includes rabies exposure status based on a combination of clinic-based triage and contact
  tracing (Rajeev et al. 2018)
- Travel times estimated from the Malaria Atlas Project's global friction surface for 2015
  - We use the global friction surface for 2015 generated by the Malaria Atlas Project ( https://map.ox.ac.uk/research-project/accessibility_to_cities/, Weiss et al. 2015,) and GPS points of clinics to get travel time to the nearest ARMC for the country of Madagascar at a 1 x 1 km scale. 
  - We then calculated a weighted average by human population to the commune or district level, using administrative shapefiles available trhough the UN Office for the Coordination of Humanitarian Affairs.
  - For each clinic, we defined the catchment area as all communes for which the clinic was the closest ARMC.
- Human population estimates were taken from the 2015 UN adjusted population projections from World Pop (www.worldpop.org, Linaird et al. 2012) and also aggreagated to the designated admin level. 

```{r directory, echo = FALSE, message = FALSE, warning = FALSE, results = 'hide'}
rm(list = ls())
library(knitr)
library(RImagePalette)
library(jpeg)
library(tidyverse)
library(lubridate)
library(magrittr)
library(rgdal)
library(broom)
select <- dplyr::select
knitr::opts_chunk$set(fig.pos = 'h', echo = FALSE, message = FALSE, warning = FALSE, results = 'hide')
```

```{r get data}
## read in data
ctar_data <- read.csv("data/SaisieRage_DATA_2018-09-21_1755.csv")
ctar_metadata <- read.csv("data/ctar_metadata.csv")
mada_district <- readOGR("data/MadaGIS/MadaPops.shp")
mada_communes <- readOGR("output/communes/communes_extracted.shp")

## catchment data
dist_catchments <- read.csv("output/catchments_district_unmasked.csv", row.names = 1)
names(dist_catchments) <- c("mdg_dis_co", "CTAR", "ttimes_weighted")
comm_catchments <- read.csv("output/catchments_commune_unmasked.csv", row.names = 1)
names(comm_catchments) <- c("mdg_cm_", "CTAR", "ttimes_weighted")

## Centers with no data
no_data <- c("IPM", "Fianarantsoa", "Ambatomainty", "Ambovombe Androy",
             "Antsiranana", "Mandritsara", "Marolambo", "Nosy be", "Sainte Marie",
             "Taolagnaro", "Tsiroanomandidy", "Vangaindrano")
ctar_metadata$exclude <- 0
ctar_metadata$exclude[ctar_metadata$CTAR %in% no_data] <- 1

## Getting ctar district and commune
ctar_metadata$ctar_dist <- mada_district$mdg_dis_co[match(ctar_metadata$District, 
                                                           mada_district$district)]
pts <- SpatialPoints(cbind(ctar_metadata$LONGITUDE, ctar_metadata$LATITUDE), 
                   proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
ctar_metadata$ctar_comm <- over(pts, mada_communes)$mdg_cm_
dist_catchments$ctar_in_dist <- ifelse(dist_catchments$mdg_dis_co %in% ctar_metadata$ctar_dist, 1, 0)
comm_catchments$ctar_in_comm <- ifelse(comm_catchments$mdg_cm_ %in% ctar_metadata$ctar_comm, 1, 0)
```

```{r network fig}
## Network fig
## Revise: points = CTAR points with size proportional to number of bites reported, lines to district proportional to the number of bites from that district, outline = by district, communes = polygons shaded by catchments?

## Get color palette from other network fig!
img <- readJPEG("~/Downloads/Dp0j4GNUwAAPPJV.jpeg")
pal <- image_palette(img, 31)
add.alpha <- function(col, alpha=1){
  if(missing(col))
    stop("Please provide a vector of colours.")
  apply(sapply(col, col2rgb)/255, 2, 
                     function(x) 
                       rgb(x[1], x[2], x[3], alpha=alpha))  
}
ctar_metadata$color <- c("#FCC56F","#FFDBE5", "#7A4900", "#CBCDD2", "#0000A6", "#EFF2F1",
                 "#63FFAC", "#B79762", "#004D43", "#8FB0FF", "#997D87", "#FD9C54", "#8362B5",
                 "#578FB0","#5A0007", "#809693", "#D16100", "#1B4400", "#4FC601", "#3B5DFF", 
                 "#4A3B53", "#FF2F80","#61615A", "#BA0900", "#6B7900", "#00C2A0", "#FFAA92",
                 "#FF90C9", "#B903AA", "#FEFFE6", "#E9E9D2")
ctar_metadata$fill <- ctar_metadata$color
ctar_metadata$fill[ctar_metadata$CTAR %in% no_data] <- "#D3D3D3"
ctar_metadata$fill <- add.alpha(ctar_metadata$fill, 0.25)

display_palette(ctar_metadata$color)
dist_catchments %>% left_join(select(ctar_metadata, CTAR, exclude, 
                                     color, fill, ctar_dist, LATITUDE, LONGITUDE)) -> dist_catchments
mada_district@data <- left_join(mada_district@data, dist_catchments)

## get exposure matrix
ctar_data %>% 
  group_by(district, id_ctar) %>% # group by district and ctar
  summarize(n = n()) -> exp_mat # get count of exposures
dist_points <- cbind(select(mada_district@data,
                            mdg_dis_co), coordinates(mada_district))
names(dist_points)[2:3] <- c("dist_long", "dist_lat")
dist_points %>%
 left_join(select(ctar_metadata, ctar_dist, LATITUDE, LONGITUDE), 
           by = c("mdg_dis_co" = "ctar_dist")) %>%
 mutate(dist_long = coalesce(dist_long, LONGITUDE), 
        dist_lat = coalesce(dist_lat, LATITUDE)) -> dist_points

exp_mat %>% 
  left_join(select(dist_points, mdg_dis_co, dist_long, dist_lat), 
            by = c("district" = "mdg_dis_co")) %>%
  left_join(select(ctar_metadata, id_ctar, LATITUDE, LONGITUDE,
                   color, fill, ctar_dist)) -> dist_lines
dist_lines$size <- log(dist_lines$n + 0.1)*0.2

ctar_data %>%
  group_by(district) %>%
  summarize(n = n()) %>%
  right_join(select(dist_points, mdg_dis_co, dist_long, dist_lat),
             by = c("district" = "mdg_dis_co")) %>%
  left_join(dist_catchments, by = c("district" = "mdg_dis_co") ) -> dist_points
dist_points$size <- log(dist_points$n + 0.1)*0.25

pdf("figs/network_1.pdf")
plot(mada_district, col = mada_district$fill, border = "grey") 
points(jitter(dist_lines$dist_long, factor = 2), jitter(dist_lines$dist_lat, factor = 2)
       , pch = 1, cex = dist_points$size, 
       col = dist_lines$color)
segments(dist_lines$LONGITUDE, dist_lines$LATITUDE, x1 = dist_lines$dist_long, y1 = dist_lines$dist_lat,
         lwd = dist_lines$size*2, col = dist_lines$color)
dev.off()

exp_mat %>% 
  left_join(select(ctar_metadata, CTAR, id_ctar)) %>%
  left_join(select(dist_catchments, mdg_dis_co, CTAR, exclude), by = c("district" = "mdg_dis_co")) %>%
  group_by(district) %>%
  mutate(prop = n/sum(n),
         catch_match = ifelse(CTAR.x == CTAR.y, 1, 0)) -> catch_check
hist(catch_check$prop)
ggplot(data = catch_check, aes(CTAR.x, district)) + 
  geom_tile(aes(fill = prop)) +
  scale_fill_continuous(type = "viridis", name = "proportion") +
  geom_text(label = catch_check$catch_match)
```


```{r clinic level reporting}
######### Patient time series
ctar_data %>%
  select(id_ctar, date_de_consultation) %>%
  mutate(date_de_consultation = ymd(date_de_consultation)) %>%
  gather(dose, date_de_consultation, -id_ctar) %>%
  group_by(id_ctar, date_de_consultation) %>%
  summarise(n = n()) -> patient_ts
patient_ts <- patient_ts[!is.na(patient_ts$date_de_consultation), ]
patient_ts$ctar <- ctar_metadata$CTAR[match(patient_ts$id_ctar, ctar_metadata$id_ctar)]
patient_ts <- patient_ts[!is.na(patient_ts$ctar), ]

ggplot(data = patient_ts, aes(date_de_consultation, ctar)) + 
  geom_tile(aes(fill = n)) +
  scale_fill_continuous(type = "viridis", name = "Patients") 

## getting reporting
start_date <- ymd("2014-01-01")
end_date <- ymd("2017-12-31")
ts <- as_tibble(seq(start_date, end_date, by = "day"))

patient_ts %>%
  right_join(ts, by = c("date_de_consultation" = "value")) %>%
  select(id_ctar, date_de_consultation, n) %>%
  spread(id_ctar, n) %>%
  replace(., is.na(.), 0) -> doses_wide
dose_mat <- as.matrix(doses_wide[, 2:(ncol(doses_wide) - 1)])

date_mat <- matrix(NA, nrow(dose_mat), ncol(dose_mat))
for (j in 1:ncol(date_mat)){
  rle(dose_mat[ , j]) %>%
    unclass() %>%
    as.data.frame() %>%
    mutate(end = cumsum(lengths),
         start = c(1, lag(end)[-1] + 1)) %>%
    filter(values == 0, lengths >= 10) -> rles
  for (i in 1:nrow(rles)){
    date_mat[rles$start[i]:rles$end[i], j] <- 0
  }
}

date_mat <- replace(date_mat, is.na(date_mat), 1)
date_mat %>% 
  as_tibble() %>%
  group_by(date = year(doses_wide$date_de_consultation)) %>%
  summarise_all(funs(sum(.)/n())) -> clinic_reporting
colnames(clinic_reporting) <- colnames(doses_wide)[1:(ncol(doses_wide)-1)]
clinic_reporting <- gather(clinic_reporting, id_ctar, prop, -date_de_consultation)
clinic_reporting$ctar <- ctar_metadata$CTAR[match(clinic_reporting$id_ctar, 
                                                  ctar_metadata$id_ctar)]
clinic_reporting$id_ctar <- as.numeric(clinic_reporting$id_ctar)

ggplot(clinic_reporting, aes(x = date_de_consultation, y = ctar, fill = prop)) + 
  geom_tile() +
  scale_fill_gradient(low = "white", high = "blue")
```


```{r district level exposures}
## districts that are non-reporter and data not available yet CTAR
mada_district@data %>%
select(district = mdg_dis_co, pop = pop2015adj, ttimes_weighted, CTAR, exclude) -> covars

to_exclude <- c(grep("contact", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("contam", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("consom", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("passage", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE))
to_exclude <- to_exclude[-grep("date", to_exclude, ignore.case = TRUE)]
ctar_data$excl <- 0
ctar_data$excl[ctar_data$remarque %in% to_exclude] <- 1

ctar_data %>% 
  filter(excl != 1) %>% # exclude contacts
  mutate_at(vars(starts_with("date")), funs(ymd(.))) %>% # format dates
  group_by(year = year(date_de_consultation), district, id_ctar) %>% # group by year and district
  summarize(n = n()) -> exposures # get count of exposures

exposures %>%
  rename(date = year) %>%
  left_join(covars) %>% # add pop + ttimes + reporting
  left_join(clinic_reporting) %>%   # add reporting by clinic + year
  filter(exclude == 0, prop > 0.25) -> exps_cleaned 

exps_cleaned %>%
  group_by(district, date) %>%
  mutate(bites = n/prop) %>%
  summarise(bites = sum(bites, na.rm = TRUE)) %>%
  group_by(district) %>%
  summarise(bites = mean(bites)) %>%
  left_join(covars) -> exps_dist

exps_cleaned %>%
  group_by(ctar, date) %>% ## Need to rename CTAR so clear if it's CTAR in catchment vs. ctar of bites...
  mutate(bites = n/prop) %>%
  summarise(bites = sum(bites, na.rm = TRUE)) %>%
  group_by(ctar) %>%
  summarise(bites = mean(bites)) -> exps_ctar

```

```{r ttimes + pop at commune level}
## Need: weighted ttimes, pop, ctar_in, exclude
comm_catchments %>%
  left_join(select(mada_communes@data, pop = MDG__201, mdg_cm_, district = mtch_ds)) -> comm_covars
comm_covars <- filter(comm_covars, ttimes_weighted != "Inf")
comm_covars %>% 
  left_join(select(mada_district@data, mdg_dis_co, district)) -> comm_data
comm_data$exclude <- dist_catchments$exclude[match(comm_data$mdg_dis_co, dist_catchments$mdg_dis_co)]

## Data to include
nrow(comm_data) - sum(comm_data$exclude)
```

```{r likelihood of observing district data given sum of communes in district}
library()

get.likelihood <- function(commune,district, params) {
  # To test likelihood function
  # commune = comm_data
  # district = exps_dist
  # params = c(1e-6, 0.1)
  B_ttimes <- params[1]
  B_0 <- params[2]
  commune %>%
      filter(exclude == 0) %>%
      group_by(mdg_dis_co) %>%
      mutate(bites = exp(B_ttimes*ttimes_weighted + B_0)*pop) %>%
      summarize(sum_bites = sum(bites)) %>%
      left_join(select(district, district, dist_bites = bites), 
                by = c("mdg_dis_co" = "district")) %>%
      filter(!is.na(dist_bites)) -> sum_bites
  return(-sum(dpois(round(sum_bites$dist_bites), lambda = sum_bites$sum_bites, log = TRUE)))
}

tmp <- optim(par = c(1e-6, 0.1), get.likelihood, district = exps_dist,
             commune = comm_data, hessian = TRUE)
params <- tmp$par
B_ttimes <- params[1]
B_0 <- params[2]

comm_data %>%
      filter(exclude == 0) %>%
      group_by(mdg_dis_co) %>%
      mutate(bites = exp(B_ttimes*ttimes_weighted + B_0)*pop) -> check
plot(check$ttimes_weighted, check$bites)

comm_data %>%
      filter(exclude == 0) %>%
      group_by(mdg_dis_co) %>%
      mutate(bites = exp(B_ttimes*ttimes_weighted + B_0)*pop) %>%
      summarize(sum_bites = sum(bites)) %>%
      left_join(select(district, district, dist_bites = bites), 
                by = c("mdg_dis_co" = "district")) %>%
      filter(!is.na(dist_bites)) -> sum_bites
sum_bites %$% plot(dist_bites, sum_bites)
abline(a = 0, b = 1, col = "blue", lty = 2)

```

## Model of reported bites as a function of travel time
As bite patient data were only available...

Excluding any catchments for which there was less than 25% estimated form submission, we calculated the average bite incidence corrected by the annual undersubmission of forms at the district level.

We fit a linear mixed effects model where the annual average bite incidence at the district level was predicted by the average travel time to the nearest CTAR for the district, the population within the district, and a random catchment level effect.

For three other catchments with reporting above x% we used to out-of-fit predict...
Ability to predict average annual/monthly bite incidence by travel time
Ability to predict out-of-fit to other catchments 

<br>

### Estimation of burden and reporting 
We used our model to predict average annual bite incidence for all 114 districts in Madagascar, and estimated deaths due to rabies given this and assumptions about rabies exposures.

We calculated deaths as:
$$deaths_{i} = (R_{i} - ({p_{rabid} \times B_{i})) \times p_{death}$$

where the proportion of reported bites that are rabies exposures ($p_{rabid}$) are defined as:
$$
           p_{rabid}=
            \begin{cases}
            x, & \text{if}\ \frac{R_i \times \rho_{max}}{B_i} > x \\
            \frac{R_i}{B_i}, & \text{otherwise}
            \end{cases}
$$
<br>

such that rabid reported bites (i.e. $p_{rabid}\timesB_{i}$) cannot exceed the expected number of human exposures given maximum reporting (i.e. $R_{i} \times \rho_{max}$. $p_{rabid}$ is taken from Rajeev et al. 2018 on contact tracing data from the Moramanga District. 

$R_{i}$ is drawn from a uniform distribution between the minimum and maximum expected number of human exposures. We calculate this as:
    
<br>

$$r \times D \times p_{exp}$$ 
    
<br>

where $r$ is rabies incidence in dogs in the absence of any vaccination multiplied by the estimated dog population in the commune ($D_i$) and the exposure rate per rabid dogs ($p_{exp}$ = 0.39 persons exposed per rabid dog)(Hampson et al. 2018). We estimate the dog population by using a human:dog ratio of 5 to generate our maximum expected incidence and an HDR of 25 for our minimum expected incidence. As there is little data on dog populations in Madagascar, this range of HDRs encompasses a wide range observed across Africa(cite?). 
  
<br>

## Estimating the impact of expanding PEP Access
We use this framework to compare three scenarios of PEP provisioning in Madagascar:
1. The baseline with the current clinic locations (n = 31)
2. Expansion of ARMC to one clinic per district (n = 114)
3. Expansion of ARMC to all CSB IIs (n = ...?)

We use data on the location of **CSBs** provided by IPM to regenerate travel times to the nearest ARMC given expansion as per scenario 2 and 3. We then predict the expected bite incidence from the model given these new travel times and compare the relative decreases in burden for the three scenarios.

<br>

### Sensitivity Analyses
- Sensitivity to assumptions of R
- Sensitivity to assumptions of p_rabid

```{r}
## get vials delivered
ctar_metadata %>% 
  dplyr::select(id_ctar, starts_with("doses")) %>%
  gather(year, vials_delivered, -id_ctar) %>%
  mutate(year = as.numeric(substr(as.character(year), 7, 10))) -> vials_delivered

## getting dose time series by clinic
########### Need to fix dates first! ###############
ctar_data %>%
  select(id_ctar, datej0, datej3, datej7, datej28) %>%
  mutate_at(vars(starts_with("date")), funs(ymd(.))) %>%
  gather(dose, date, -id_ctar) %>%
  group_by(id_ctar, date) %>%
  summarise(n = n()) -> dose_ts
dose_ts <- dose_ts[!is.na(dose_ts$date), ]
dose_ts$ctar <- ctar_metadata$CTAR[match(dose_ts$id_ctar, ctar_metadata$id_ctar)]
dose_ts <- dose_ts[!is.na(dose_ts$ctar), ]

## getting theoretical # vials by year
dose_ts %>%
  mutate(year = year(date), vials = ceiling(n/2)) %>%
  group_by(id_ctar, year) %>%
  summarize(vials_estimated = sum(vials)) %>%
  left_join(vials_delivered) -> dose_comp

######### Patient time series
ctar_data %>%
  select(id_ctar, date_de_consultation) %>%
  mutate(date_de_consultation = ymd(date_de_consultation)) %>%
  gather(dose, date_de_consultation, -id_ctar) %>%
  group_by(id_ctar, date_de_consultation) %>%
  summarise(n = n()) -> patient_ts
patient_ts <- patient_ts[!is.na(patient_ts$date_de_consultation), ]
patient_ts$ctar <- ctar_metadata$CTAR[match(patient_ts$id_ctar, ctar_metadata$id_ctar)]
patient_ts <- patient_ts[!is.na(patient_ts$ctar), ]

ggplot(data = patient_ts, aes(date_de_consultation, ctar)) + 
  geom_tile(aes(fill = n)) +
  scale_fill_continuous(type = "viridis", name = "Patients") 

patient_ts %>%
  filter(id_ctar == 1) %$%
  hist(n, breaks = 100, col = "blue", 
       xlab = "Patients reporting", main = "Soanierana Ivongo")
patient_ts %>%
  filter(ctar == "Toamasina") %$%
  hist(n, breaks = 100, 
       xlab = "Patients reporting", main = "Toamasina", col = "red")

## getting reporting
start_date <- ymd("2014-01-01")
end_date <- ymd("2017-12-31")
ts <- as_tibble(seq(start_date, end_date, by = "day"))

patient_ts %>%
  right_join(ts, by = c("date_de_consultation" = "value")) %>%
  select(id_ctar, date_de_consultation, n) %>%
  spread(id_ctar, n) %>%
  replace(., is.na(.), 0) -> doses_wide
dose_mat <- as.matrix(doses_wide[, 2:(ncol(doses_wide) - 1)])

date_mat <- matrix(NA, nrow(dose_mat), ncol(dose_mat))
for (j in 1:ncol(date_mat)){
  rle(dose_mat[ , j]) %>%
    unclass() %>%
    as.data.frame() %>%
    mutate(end = cumsum(lengths),
         start = c(1, lag(end)[-1] + 1)) %>%
    filter(values == 0, lengths >= 10) -> rles
  for (i in 1:nrow(rles)){
    date_mat[rles$start[i]:rles$end[i], j] <- 0
  }
}

date_mat <- replace(date_mat, is.na(date_mat), 1)
date_mat %>% 
  as_tibble() %>%
  group_by(date = year(doses_wide$date_de_consultation)) %>%
  summarise_all(funs(sum(.)/n())) -> clinic_reporting
colnames(clinic_reporting) <- colnames(doses_wide)[1:(ncol(doses_wide)-1)]
clinic_reporting <- gather(clinic_reporting, id_ctar, prop, -date_de_consultation)
clinic_reporting$ctar <- ctar_metadata$CTAR[match(clinic_reporting$id_ctar, 
                                                  ctar_metadata$id_ctar)]
clinic_reporting$id_ctar <- as.numeric(clinic_reporting$id_ctar)

ggplot(clinic_reporting, aes(x = date_de_consultation, y = ctar, fill = prop)) + 
  geom_tile() +
  scale_fill_gradient(low = "white", high = "blue")
```



## Submission of forms
- Missingness seems to have been due to periods of time without form submission
- Calculating periods of time 

```{r clean data}
## districts that are non-reporter and data not available yet CTAR
mada_district@data %>%
select(district = mdg_dis_co, pop = pop2015adj, ttimes_weighted, CTAR, exclude) -> covars

to_exclude <- c(grep("contact", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("contam", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("consom", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("passage", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE))
to_exclude <- to_exclude[-grep("date", to_exclude, ignore.case = TRUE)]
ctar_data$excl <- 0
ctar_data$excl[ctar_data$remarque %in% to_exclude] <- 1

ctar_data %>% 
  filter(excl != 1) %>% # exclude contacts
  mutate_at(vars(starts_with("date")), funs(ymd(.))) %>% # format dates
  group_by(year = year(date_de_consultation), district, id_ctar) %>% # group by year and district
  summarize(n = n()) -> exposures # get count of exposures

exposures %>%
  rename(date = year) %>%
  left_join(covars) %>% # add pop + ttimes + reporting
  left_join(clinic_reporting) %>%   # add reporting by clinic + year
  filter(exclude == 0, prop > 0.25) %>%
  group_by(district, date) %>%
  mutate(bites = n/prop) %>%
  summarise(bites = sum(bites, na.rm = TRUE)) -> exps_cleaned 
exps_cleaned %>%
  group_by(district) %>%
  summarise(bites = mean(bites)) %>%
  left_join(covars) -> exps_cleaned

library(lme4)

## poisson with total pop as offset
mod <- glm(round(bites) ~ ttimes_weighted + offset(log(round(pop))), 
                 data = exps_cleaned, family = poisson)
par(mfrow = c(2, 1), mar = c(4, 4, 1, 1))
plot(exps_cleaned$bites, predict(mod, type = "response"), bty = "l", pch = 20,
     xlab = "Observed bites", ylab = "Predicted bites")
abline(a = 0, b = 1, lty = 2, col = "blue")
legend("topright", col = "blue", legend = "1:1 line", lty = 2, bty = "n", seg.len = 1, 
       inset = c(0.0, -0.1))
plot(exps_cleaned$ttimes_weighted/60, predict(mod, type = "response"), bty = "l", pch = 20,
     xlab = "Travel times (hrs)", ylab = "Bites", col = alpha("blue", 0.7), 
     ylim = c(0, max(exps_cleaned$bites)))
points(exps_cleaned$ttimes_weighted/60, exps_cleaned$bites, bty = "l", pch = 20,
     xlab = "Travel times (hrs)", col = alpha("darkred", 0.7))
legend("topright", col = c(alpha("blue", 0.7), alpha("darkred", 0.7)), legend = c("Predicted", "Observed"), 
       pch = 20, bty = "n")
```


```{r functions for getting burden}
get.burden <- function(covs = covars, pop = covars$pop, model = mod,
                       p_rabid = 0.5, rho_max = 0.9,
                       max_HDR = 25, min_HDR = 5, 
                       dog_rabies_inc = 0.01, human_exp_rate = 0.39, 
                       prob_death = 0.16, nsims = 1000) {
  store_deaths <- store_p_rabid <- matrix(NA, nrow(covs), nsims)

  for (i in 1:nsims) {
    mean_bites <- predict(model, type = "response", newdata = covs)
    bites <- rpois(length(mean_bites), mean_bites)
    mean_exps <- runif(length(pop), min = human_exp_rate*dog_rabies_inc*pop/max_HDR, 
                    max = human_exp_rate*dog_rabies_inc*pop/min_HDR)
    rabid_exps <- rpois(length(mean_bites), mean_exps)
    p_rabid_t <- ifelse(bites*p_rabid/rabid_exps > rho_max, (rho_max*rabid_exps)/bites, p_rabid)
    deaths <- rbinom(length(mean_bites), rabid_exps - round(bites*p_rabid_t), prob_death)
    store_deaths[, i] <- deaths
    store_p_rabid[, i] <- p_rabid_t
  }
  
  results <- cbind(get.meanCI(store_deaths), get.meanCI(store_p_rabid))
  colnames(results) <- c("deaths_mean", "deaths_lowerCI", "deaths_upperCI",
                         "p_rabid_mean", "p_rabid_lowerCI", "p_rabid_upperCI")
  results <- cbind(covars, results)
  return(results)
}

get.burden.flat <- function(covs = covars, pop = covars$pop, model = mod,
                       p_rabid = 0.5, rho = 0.85, 
                       prob_death = 0.16, nsims = 1000) {
  store_deaths <- matrix(NA, nrow(covs), nsims)

  for (i in 1:nsims) {
    mean_bites <- predict(model, type = "response", newdata = covs)
    bites <- rpois(length(mean_bites), mean_bites)
    unreported <- bites*p_rabid/rho - bites*p_rabid
    deaths <- rbinom(length(mean_bites), round(unreported), prob_death)
    store_deaths[, i] <- deaths
  }
  results <- get.meanCI(store_deaths)
  colnames(results) <- c("deaths_mean", "death_lowerCI", "deaths_upperCI")
  results <- cbind(covars, results)
  return(results)
}

get.meanCI <- function(matrix_by_row, nboots = 1000) {
    mean_rows <- apply(matrix_by_row, 1, mean)
    CIs <- apply(matrix_by_row, 1, boots, nboot = nboots)
    lower <- unlist(CIs)[1, ] 
    upper <- unlist(CIs)[2, ]
    summ <- cbind(mean_rows, lower, upper)
    colnames(summ) <- c("mean", "lower", "upper")
    return(summ)
}

boots <- function(x, nboot = 1000){
  n = length(x)
  xbar = mean(x)
  tmpdata = sample(x,n*nboot, replace=TRUE)
  bootstrapsample = matrix(tmpdata, nrow=n, ncol=nboot)
  bsmeans = colMeans(bootstrapsample)
  deltastar = bsmeans - xbar
  d = quantile(deltastar, c(0.05, 0.95))
  ## Get from quantiles
  ci = xbar - c(d[2], d[1])

  ## Sorted CIs
  sorteddeltastar = sort(deltastar)
  # # Look at the sorted results
  # Find the .05 and .95 critical values of deltastar
  d9alt = sorteddeltastar[5]
  d1alt = sorteddeltastar[950]
  # Find and print the 80% confidence interval for the mean
  ciAlt = xbar - c(d1alt,d9alt)
  # cat(’Alternative confidence interval: ’,ciAlt, ’\n’)
  return(ci)
}

```

```{r}
results_pr20 <- get.burden(p_rabid = 0.20, rho_max = 0.98)
results_pr60 <- get.burden(p_rabid = 0.60,rho_max = 0.98)

plot(results_pr20$ttimes_weighted/60, results_pr20$deaths_mean, col = "darkred", pch = 20)
points(results_pr60$ttimes_weighted/60, results_pr60$deaths_mean, col = "red", pch = 20)
segments(x0 = results_pr60$ttimes_weighted/60, x1 = results_pr60$ttimes_weighted/60,
         y0 = results_pr60$deaths_mean, y1 = results_pr20$deaths_mean, col = "red")

results_base <- get.burden(p_rabid = 0.40, rho_max = 0.98)

p_rabid_check <- seq(0.10, 0.80, by = 0.1)
check <- data.frame(p_rabid = 0, district = NA, ttimes = 0, deaths_mean = 0)
for (i in 1:length(p_rabid_check)) {
  print(paste(i, "/", length(p_rabid_check)))
  results <- get.burden(p_rabid = p_rabid_check[i], rho_max = 0.98)
  p_rabid <- rep(p_rabid_check[i], length(results$deaths_mean))
  check_one <- cbind(p_rabid, results$district, results$ttimes, results$deaths_mean)
  colnames(check_one) <- c("p_rabid", "district", "ttimes", "deaths_mean")
  check <- rbind(check, check_one)
}

check <- check[-1, ]
check$base <- rep(results_base$deaths_mean, length(p_rabid_check))
ggplot(data = check, aes(x = as.factor(p_rabid), y = as.factor(reorder(district, ttimes)))) + 
  geom_tile(aes(fill = deaths_mean/base)) +
  scale_fill_gradient2(high = "red", mid = "white", low = "blue", midpoint = 1, name = "Mean deaths") 

rho_max_check <- seq(0.90, 0.99, by = 0.01)
check <- data.frame(rho_max = 0, district = NA, ttimes = 0, deaths_mean = 0)
for (i in 1:length(rho_max_check)) {
  print(paste(i, "/", length(rho_max_check)))
  results <- get.burden(p_rabid = 0.4, rho_max = rho_max_check[i])
  rho_max <- rep(rho_max_check[i], length(results$deaths_mean))
  check_one <- cbind(rho_max, results$district, results$ttimes, results$deaths_mean)
  colnames(check_one) <- c("rho_max", "district", "ttimes", "deaths_mean")
  check <- rbind(check, check_one)
}

check <- check[-1, ]
check$base <- rep(results_base$deaths_mean, length(rho_max_check))
check %>%
  group_by(district) %>%
  mutate(min = min(deaths_mean), max = max(deaths_mean), 
         standardized = (deaths_mean - base)/(max - base)) -> check

ggplot(data = check, aes(x = as.factor(p_rabid), y = as.factor(reorder(district, ttimes)))) + 
  geom_tile(aes(fill = standardized)) +
  scale_fill_gradient2(high = "red", mid = "white", low = "blue", midpoint = 0, name = "Mean deaths") 
ggplot(data = check, aes(x = as.factor(p_rabid), y = as.factor(reorder(district, ttimes)))) + 
  geom_tile(aes(fill = deaths_mean)) +
  scale_fill_gradient2(high = "red", mid = "white", low = "blue", midpoint = 0, name = "Mean deaths") 

mada_dist_gg <- tidy(mada_district, region = "mdg_dis_co")
mada_dist_gg <- left_join(mada_dist_gg, exps_cleaned, by = c("id" = "district"))

ggplot() +
  geom_polygon(data = mada_dist_gg, aes(x = long, y = lat, group = group, fill = CTAR)) +
  scale_colour_viridis_d()

```

