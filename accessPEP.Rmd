---
title: "Estimating Access to Rabies Post-Exposure Prophylaxis in Madagascar"
author: ""
date: 
output:
  html_document: default
  pdf_document:
    includes:
      in_header: mystyle.sty
  word_document:
    reference_docx: format_docs/word_styles_reference_01.docx
css: style.css
---

## INTRODUCTION

[Start broadly with inequity?]

<br>

Canine rabies causes an estimated 59,000 human deaths annually. Post-exposure prophylaxis (PEP) prevents fatalities if delivered in a timely manner, however, access to this intervention is highly limited in areas where the disease is endemic. Data on true rabies exposures in humans and incidence in animals is also lacking in most of these countries. Often, the only data available are numbers of bite victims reporting to health facilities. The majority of rabies burden studies use these data to estimate burden of rabies from probability decision tree frameworks, often with the key assumption that overall reported bite incidence (i.e. both bites due to non-rabid and rabid animals) are proportional to rabies incidence (i.e. the more overall bites reported in a location, the higher the incidence of *rabies* exposures there) and that reporting is uniform across space. 

The most recent estimation of burden and the impact of PEP used another approach, using transmission dynamic models as the backbone to predict incidence based on level of vaccination coverage and size of the dog population at the national level. Using transmission dynamic models to estimate incidence could improve upon previous studies which may overestimate rabies burden in areas of high reporting and underestimate in areas with low reporting due to the assumption that overall reported bite incidence is proportional to rabies incidence.

<br>

Here, we extend this framework to include spatial access to PEP, using bite patient data from 19 clinics in Madagascar, a rabies endemic country that lacks a national strategy for controlling rabies in domestic dogs. Institut Pasteur de Madagascar (IPM) provides PEP at no-cost to the government or to patients that present to 31 clinics across the country. PEP is not available at any other public clinics or through the private sector. Given that rabies is endemic in the country and there is effectively no vaccination of domestic dogs, we use the baseline predictions of incidence from the dynamic model reported in Hampson et al. 2018. We flip the standard decision tree and make the assumption that reported bite incidence reflects access and reporting to PEP rather than differences in rabies incidence, using travel times to clinics as a predictor of bites reported to clinics. Assuming a range of exposure incidence given endemic rabies, we generate sub-national estimates of rabies burden and explore the impacts of expanding access to PEP in Madagascar. 

Other analyses = vials vs. additional deaths averted (given non-rabid exposures) (# vials of PEP per death averted for baseline + expanded1 + expanded2)

## METHODS

- Patient data from 19 ARMC accross the country over four years (2013 - 2017)
  - includes dates and home locations (to the district level) of patient reporting for PEP
- Patient data from Moramanga ARMC over 28 months (Sep 2016 - Dec 2018)
  - includes dates and home locations (to the commune level) of patients reporting for PEP
  - also includes rabies exposure status based on a combination of clinic-based triage and contact
  tracing (Rajeev et al. 2018)
- Travel times estimated from the Malaria Atlas Project's global friction surface for 2015
  - We use the global friction surface for 2015 generated by the Malaria Atlas Project ( https://map.ox.ac.uk/research-project/accessibility_to_cities/, Weiss et al. 2015,) and GPS points of clinics to get travel time to the nearest ARMC for the country of Madagascar at a 1 x 1 km scale. 
  - We then calculated a weighted average by human population to the commune or district level, using administrative shapefiles available trhough the UN Office for the Coordination of Humanitarian Affairs.
  - For each clinic, we defined the catchment area as all communes for which the clinic was the closest ARMC.
- Human population estimates were taken from the 2015 UN adjusted population projections from World Pop (www.worldpop.org, Linaird et al. 2012) and also aggreagated to the designated admin level.

### Bite patient data
We used the database of bite patient forms submitted from 24 ARMC between 2014 - 2017. These were individual patient data forms that were submitted to IPM as frequently as monthly to annually by clinics. Two clinics, the IPM ARMC and the Fianarantsoa ARMC used computer databases from which the data during this period were extracted and merged to the larger database. These data include the administrative district of the bite patient's address. As previous analyses showed likely substantial undersubmission of forms from clinics (*cite baseline data paper*), we calculated the proportion of days of the year for which forms were submitted. We excluded periods with 10 or more consecutive dates with no patient forms and calculated the proportion of days included per year. 

RIG data?

<br>

### GIS Data
We use the global friction surface for 2015 generated by the Malaria Atlas Project ( https://map.ox.ac.uk/research-project/accessibility_to_cities/, Weiss et al. 2015,) and GPS points of clinics to get travel time to the nearest ARMC for the country of Madagascar at a 1 x 1 km scale. We then averaged these to the commune level, using administrative shapefiles available trhough the UN Office for the Coordination of Humanitarian Affairs. For each clinic, we defined the catchment area as all communes for which the clinic was the closest ARMC. Population estimates were taken from the 2015 UN adjusted population projections from World Pop (www.worldpop.org, Linaird et al. 2012) and also aggreagated to the commune level. 

<br>

### Model of reported bites as a function of travel time
While the national bite patient data is available at the district level, travel times vary significantly within a district (see Figure SX). In order to translate the impacts of differences in access at sub-district scales to the magnitude of reported bites at the district scale, we modeled bites at the district level as the sum of incidence as a function of travel time at the commune level (sub-district administrative level). Specifically, we modeled bites as follows:
$$ 
  \mu_{d} = \sum \limits_{j=1}^jexp(\beta_{t}T_j + \beta_0)\times pop_j 
$$
where $\mu_{d}$ is the mean number of bites in district which is the sum of bites at the commune level given **commune level travel times**, $T_j$. We then estimate the likelihood of observing the bites at the district level where bites are a poisson distribution around the mean $\mu_{d}$.

As we had data available on reported bites at the commune level from the Moramanga ARMC, we modeled observed commune bites in the same framework, but un-aggregated where:
$$ 
\mu_{j} = exp(\beta_tT_j + \beta_0)\times pop_j 
$$
where $\mu_{j}$ = the mean number of bites in commune $j$ and the observed bites at the commune level follow a poisson distribution around the mean $\mu_d$. We only included communes which were designated to be within the catchment for the clinic (so primarily the Moramanga and Anosibe A'nala Districts)?? We compared our estimates of $\beta_t$ (i.e. the impact of travel time on incidence) and $\beta_0$ (the intercept) for our district data at the national level and the commune level data from the Moramanga ARMC.

P_rabid model...how to explain this one...

To better understand if ttimes might capture access, we also looked at whether pop alone can predict bites and distance could predict bites...

Ability to predict average annual/monthly bite incidence by travel time
Ability to predict out-of-fit to other catchments? Tana + Fianarantsoa?

<br>

### Estimation of burden and reporting 
We used our model to predict average annual bite incidence for all 114 districts in Madagascar, and estimated deaths due to rabies given this and assumptions about rabies exposures.

We calculated deaths as:
$$
deaths_i = (R_i - p_{rabid}B_i) \times p_{death}
$$

where the proportion of reported bites that are rabies exposures ($p_{rabid}$) are defined as:
$$
           p_{rabid}=
            \begin{cases}
            x, & \text{if}\ \frac{R_i \times \rho_{max}}{B_i} > x \\
            \frac{R_i \times \rho_{max}}{B_i}, & \text{otherwise}
            \end{cases}
$$
<br>
such that rabid reported bites (i.e. $p_{rabid} \times B_i$) cannot exceed the expected number of human exposures given maximum reporting (i.e. $R_i \times \rho_{max}$). $\rho_{max}$ taken from the Moramanga ARMC data for Moramanga Ville, the commune with the ARMC (i.e. the area with the minimum travel time).

We define $x$ in two different ways:
1. At the min and max of the range reported in Rajeev et al. 2018 for data from the Moramanga District
2. As predicted by the model of proportion rabid as a function of travel time estimated from the Moramanga ARMC data. 

$R_i$ is drawn from a uniform distribution between the minimum and maximum expected number of human exposures. We calculate this as:
    
<br>

$$r \times D \times p_{exp}$$ 
    
<br>

where $r$ is rabies incidence in dogs in the absence of any vaccination multiplied by the estimated dog population in the commune ($D_i$) and the exposure rate per rabid dogs ($p_{exp}$ = 0.39 persons exposed per rabid dog)(Hampson et al. 2018). We estimate the dog population by using a human:dog ratio of 5 to generate our maximum expected incidence and an HDR of 25 for our minimum expected incidence. As there is little data on dog populations in Madagascar, this range of HDRs encompasses a wide range observed across Africa (cite!). 

<br>

### Sensitivity Analyses
- Sensitivity to assumptions of R
- Sensitivity to assumptions of p_rabid

<br>

## Estimating the impact of expanding PEP Access
We use this framework to compare three scenarios of PEP provisioning in Madagascar:
1. The baseline with the current clinic locations (n = 31)
2. Expansion of ARMC to one clinic per district (n = 114)
3. Expansion of ARMC to all CSB IIs (n = ...?)

We use data on the location of **CSBs** provided by IPM to regenerate travel times to the nearest ARMC given expansion as per scenario 2 and 3. We then predict the expected bite incidence from the model given these new travel times and compare the relative decreases in burden for the three scenarios.


## Results 

```{r directory, echo = FALSE, message = FALSE, warning = FALSE, results = 'hide'}
rm(list = ls())
library(knitr)
library(RImagePalette)
library(jpeg)
library(tidyverse)
library(lubridate)
library(magrittr)
library(rgdal)
library(broom)
select <- dplyr::select
knitr::opts_chunk$set(fig.pos = 'h', echo = FALSE, message = FALSE, warning = FALSE, results = 'hide')
```



### Clinic catchments and reporting
```{r get data}
## read in data
ctar_data <- read.csv("data/SaisieRage_DATA_2018-09-21_1755.csv")
ctar_metadata <- read.csv("data/ctar_metadata.csv")
mada_district <- readOGR("data/MadaGIS/MadaPops.shp")
mada_communes <- readOGR("output/communes/communes_extracted.shp")

## catchment data
dist_catchments <- read.csv("output/catchments_district_unmasked.csv", row.names = 1)
names(dist_catchments) <- c("mdg_dis_co", "CTAR", "ttimes_weighted")
comm_catchments <- read.csv("output/catchments_commune_unmasked.csv", row.names = 1)
names(comm_catchments) <- c("mdg_cm_", "CTAR", "ttimes_weighted")

## Centers with no data
no_data <- c("IPM", "Fianarantsoa", "Ambatomainty", "Ambovombe Androy",
             "Antsiranana", "Mandritsara", "Marolambo", "Nosy be", "Sainte Marie",
             "Taolagnaro", "Tsiroanomandidy", "Vangaindrano")
ctar_metadata$exclude <- 0
ctar_metadata$exclude[ctar_metadata$CTAR %in% no_data] <- 1

## Getting ctar district and commune
ctar_metadata$ctar_dist <- mada_district$mdg_dis_co[match(ctar_metadata$District, 
                                                           mada_district$district)]
pts <- SpatialPoints(cbind(ctar_metadata$LONGITUDE, ctar_metadata$LATITUDE), 
                   proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
ctar_metadata$ctar_comm <- over(pts, mada_communes)$mdg_cm_
dist_catchments$ctar_in_dist <- ifelse(dist_catchments$mdg_dis_co %in% ctar_metadata$ctar_dist, 1, 0)
comm_catchments$ctar_in_comm <- ifelse(comm_catchments$mdg_cm_ %in% ctar_metadata$ctar_comm, 1, 0)
```


```{r network fig}
## Network fig
## Revise: points = CTAR points with size proportional to number of bites reported, lines to district proportional to the number of bites from that district, outline = by district, communes = polygons shaded by catchments?

## Get color palette from other network fig!
img <- readJPEG("~/Downloads/Dp0j4GNUwAAPPJV.jpeg")
pal <- image_palette(img, 31)
add.alpha <- function(col, alpha=1){
  if(missing(col))
    stop("Please provide a vector of colours.")
  apply(sapply(col, col2rgb)/255, 2, 
                     function(x) 
                       rgb(x[1], x[2], x[3], alpha=alpha))  
}
ctar_metadata$color <- c("#FCC56F","#FFDBE5", "#7A4900", "#CBCDD2", "#0000A6", "#EFF2F1",
                 "#63FFAC", "#B79762", "#004D43", "#8FB0FF", "#997D87", "#FD9C54", "#8362B5",
                 "#578FB0","#5A0007", "#809693", "#D16100", "#1B4400", "#4FC601", "#3B5DFF", 
                 "#4A3B53", "#FF2F80","#61615A", "#BA0900", "#6B7900", "#00C2A0", "#FFAA92",
                 "#FF90C9", "#B903AA", "#FEFFE6", "#E9E9D2")
ctar_metadata$fill <- ctar_metadata$color
ctar_metadata$fill[ctar_metadata$CTAR %in% no_data] <- "#D3D3D3"
ctar_metadata$fill <- add.alpha(ctar_metadata$fill, 0.25)

display_palette(ctar_metadata$color)
dist_catchments %>% left_join(select(ctar_metadata, CTAR, exclude, 
                                     color, fill, ctar_dist, LATITUDE, LONGITUDE)) -> dist_catchments
mada_district@data <- left_join(mada_district@data, dist_catchments)

## get exposure matrix
ctar_data %>% 
  group_by(district, id_ctar) %>% # group by district and ctar
  summarize(n = n()) -> exp_mat # get count of exposures
dist_points <- cbind(select(mada_district@data,
                            mdg_dis_co), coordinates(mada_district))
names(dist_points)[2:3] <- c("dist_long", "dist_lat")
dist_points %>%
 left_join(select(ctar_metadata, ctar_dist, LATITUDE, LONGITUDE), 
           by = c("mdg_dis_co" = "ctar_dist")) %>%
 mutate(dist_long = coalesce(dist_long, LONGITUDE), 
        dist_lat = coalesce(dist_lat, LATITUDE)) -> dist_points

exp_mat %>% 
  left_join(select(dist_points, mdg_dis_co, dist_long, dist_lat), 
            by = c("district" = "mdg_dis_co")) %>%
  left_join(select(ctar_metadata, id_ctar, LATITUDE, LONGITUDE,
                   color, fill, ctar_dist)) -> dist_lines
dist_lines$size <- log(dist_lines$n + 0.1)*0.2

ctar_data %>%
  group_by(district) %>%
  summarize(n = n()) %>%
  right_join(select(dist_points, mdg_dis_co, dist_long, dist_lat),
             by = c("district" = "mdg_dis_co")) %>%
  left_join(dist_catchments, by = c("district" = "mdg_dis_co") ) -> dist_points
dist_points$size <- log(dist_points$n + 0.1)*0.25

pdf("figs/network_1.pdf")
plot(mada_district, col = mada_district$fill, border = "grey") 
points(jitter(dist_lines$dist_long, factor = 2), jitter(dist_lines$dist_lat, factor = 2)
       , pch = 1, cex = dist_points$size, 
       col = dist_lines$color)
segments(dist_lines$LONGITUDE, dist_lines$LATITUDE, x1 = dist_lines$dist_long, y1 = dist_lines$dist_lat,
         lwd = dist_lines$size*2, col = dist_lines$color)
dev.off()

exp_mat %>% 
  left_join(select(ctar_metadata, CTAR, id_ctar)) %>%
  left_join(select(dist_catchments, mdg_dis_co, CTAR, exclude), by = c("district" = "mdg_dis_co")) %>%
  group_by(district) %>%
  mutate(prop = n/sum(n),
         catch_match = ifelse(CTAR.x == CTAR.y, 1, 0)) -> catch_check
hist(catch_check$prop)
ggplot(data = catch_check, aes(CTAR.x, district)) + 
  geom_tile(aes(fill = prop)) +
  scale_fill_continuous(type = "viridis", name = "proportion") +
  geom_text(label = catch_check$catch_match)
```


```{r clinic level reporting}
######### Patient time series
ctar_data %>%
  select(id_ctar, date_de_consultation) %>%
  mutate(date_de_consultation = ymd(date_de_consultation)) %>%
  gather(dose, date_de_consultation, -id_ctar) %>%
  group_by(id_ctar, date_de_consultation) %>%
  summarise(n = n()) -> patient_ts
patient_ts <- patient_ts[!is.na(patient_ts$date_de_consultation), ]
patient_ts$ctar <- ctar_metadata$CTAR[match(patient_ts$id_ctar, ctar_metadata$id_ctar)]
patient_ts <- patient_ts[!is.na(patient_ts$ctar), ]

ggplot(data = patient_ts, aes(date_de_consultation, ctar)) + 
  geom_tile(aes(fill = n)) +
  scale_fill_continuous(type = "viridis", name = "Patients") 

## getting reporting
start_date <- ymd("2014-01-01")
end_date <- ymd("2017-12-31")
ts <- as_tibble(seq(start_date, end_date, by = "day"))

patient_ts %>%
  right_join(ts, by = c("date_de_consultation" = "value")) %>%
  select(id_ctar, date_de_consultation, n) %>%
  spread(id_ctar, n) %>%
  replace(., is.na(.), 0) -> doses_wide
dose_mat <- as.matrix(doses_wide[, 2:(ncol(doses_wide) - 1)])

date_mat <- matrix(NA, nrow(dose_mat), ncol(dose_mat))
for (j in 1:ncol(date_mat)){
  rle(dose_mat[ , j]) %>%
    unclass() %>%
    as.data.frame() %>%
    mutate(end = cumsum(lengths),
         start = c(1, lag(end)[-1] + 1)) %>%
    filter(values == 0, lengths >= 10) -> rles
  for (i in 1:nrow(rles)){
    date_mat[rles$start[i]:rles$end[i], j] <- 0
  }
}

date_mat <- replace(date_mat, is.na(date_mat), 1)
date_mat %>% 
  as_tibble() %>%
  group_by(date = year(doses_wide$date_de_consultation)) %>%
  summarise_all(funs(sum(.)/n())) -> clinic_reporting
colnames(clinic_reporting) <- colnames(doses_wide)[1:(ncol(doses_wide)-1)]
clinic_reporting <- gather(clinic_reporting, id_ctar, prop, -date_de_consultation)
clinic_reporting$ctar <- ctar_metadata$CTAR[match(clinic_reporting$id_ctar, 
                                                  ctar_metadata$id_ctar)]
clinic_reporting$id_ctar <- as.numeric(clinic_reporting$id_ctar)

ggplot(clinic_reporting, aes(x = date_de_consultation, y = ctar, fill = prop)) + 
  geom_tile() +
  scale_fill_gradient(low = "white", high = "blue")
```


### Models of bites as a function of travel times

```{r district level exposures}
## districts that are non-reporter and data not available yet CTAR
mada_district@data %>%
select(district = mdg_dis_co, pop = pop2015adj, ttimes_weighted, CTAR, exclude) -> covars

to_exclude <- c(grep("contact", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("contam", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("consom", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE),
                grep("passage", unique(ctar_data$remarque), ignore.case = TRUE, value = TRUE))
to_exclude <- to_exclude[-grep("date", to_exclude, ignore.case = TRUE)]
ctar_data$excl <- 0
ctar_data$excl[ctar_data$remarque %in% to_exclude] <- 1

ctar_data %>% 
  filter(excl != 1) %>% # exclude contacts
  mutate_at(vars(starts_with("date")), funs(ymd(.))) %>% # format dates
  group_by(year = year(date_de_consultation), district, id_ctar) %>% # group by year and district
  summarize(n = n()) -> exposures # get count of exposures

exposures %>%
  rename(date = year) %>%
  left_join(covars) %>% # add pop + ttimes + reporting
  left_join(clinic_reporting) %>%   # add reporting by clinic + year
  filter(exclude == 0, prop > 0.25) -> exps_cleaned 

exps_cleaned %>%
  group_by(district, date) %>%
  mutate(bites = n/prop) %>%
  summarise(bites = sum(bites, na.rm = TRUE)) %>%
  group_by(district) %>%
  summarise(bites = mean(bites)) %>%
  left_join(covars) -> exps_dist

exps_cleaned %>%
  group_by(ctar, date) %>% ## Need to rename CTAR so clear if it's CTAR in catchment vs. ctar of bites...
  mutate(bites = n/prop) %>%
  summarise(bites = sum(bites, na.rm = TRUE)) %>%
  group_by(ctar) %>%
  summarise(bites = mean(bites)) -> exps_ctar

```

```{r ttimes + pop at commune level}
## Need: weighted ttimes, pop, ctar_in, exclude
comm_catchments %>%
  left_join(select(mada_communes@data, pop = MDG__201, mdg_cm_, district = mtch_ds)) -> comm_covars
comm_covars <- filter(comm_covars, ttimes_weighted != "Inf")
comm_covars %>% 
  left_join(select(mada_district@data, mdg_dis_co, district)) -> comm_data
comm_data$exclude <- dist_catchments$exclude[match(comm_data$mdg_dis_co, dist_catchments$mdg_dis_co)]

## Data to include
nrow(comm_data) - sum(comm_data$exclude)
```



```{r likelihood of observing district data given sum of communes in district}

get.likelihood <- function(commune,district, params) {
  # To test likelihood function
  # commune = comm_data
  # district = exps_dist
  # params = c(1e-6, 0.1)
  B_ttimes <- params[1]
  B_0 <- params[2]
  commune %>%
      filter(exclude == 0) %>%
      group_by(mdg_dis_co) %>%
      mutate(bites = exp(B_ttimes*ttimes_weighted + B_0)*pop) %>%
      summarize(sum_bites = sum(bites)) %>%
      left_join(select(district, district, dist_bites = bites), 
                by = c("mdg_dis_co" = "district")) %>%
      filter(!is.na(dist_bites)) -> sum_bites
  return(-sum(dpois(round(sum_bites$dist_bites), lambda = sum_bites$sum_bites, log = TRUE)))
}

tmp <- optim(par = c(1e-6, 0.1), get.likelihood, district = exps_dist,
             commune = comm_data, hessian = TRUE)
params <- tmp$par
B_ttimes <- params[1]
B_0 <- params[2]

comm_data %>%
      filter(exclude == 0) %>%
      group_by(mdg_dis_co) %>%
      mutate(bites = exp(B_ttimes*ttimes_weighted + B_0)*pop) -> check
plot(check$ttimes_weighted, check$bites)

comm_data %>%
      filter(exclude == 0) %>%
      group_by(mdg_dis_co) %>%
      mutate(bites = exp(B_ttimes*ttimes_weighted + B_0)*pop) %>%
      summarize(sum_bites = sum(bites)) %>%
      left_join(select(exps_dist, district, dist_bites = bites), 
                by = c("mdg_dis_co" = "district")) %>%
      filter(!is.na(dist_bites)) -> sum_bites
sum_bites %$% plot(dist_bites, sum_bites)
abline(a = 0, b = 1, col = "blue", lty = 2)

```

```{r checking impact of ctar in}
exps_dist$ctar_in <- dist_catchments$ctar_in_dist[match(exps_dist$district,
                                                        dist_catchments$mdg_dis_co)]
ggplot() + 
  geom_boxplot(data = exps_dist, aes(x = as.factor(ctar_in), y = bites/pop))

comm_data$ctar_in_comm <- comm_catchments$ctar_in_comm[match(comm_data$mdg_cm_,
                                                        comm_catchments$mdg_cm_)]
comm_data$ctar_in_dist <- dist_catchments$ctar_in_dist[match(comm_data$mdg_dis_co,
                                                        dist_catchments$mdg_dis_co)]

get.likelihood <- function(commune,district, params) {
  # To test likelihood function
  # commune = comm_data
  # district = exps_dist
  # params = c(1e-6, 0.1)
  B_ttimes <- params[1]
  B_in <- params[2]
  B_0 <- params[3]

  commune %>%
      filter(exclude == 0) %>%
      group_by(mdg_dis_co) %>%
      mutate(bites = exp(B_ttimes*ttimes_weighted + B_in*ctar_in_dist + B_0)*pop) %>%
      summarize(sum_bites = sum(bites)) %>%
      left_join(select(district, district, dist_bites = bites), 
                by = c("mdg_dis_co" = "district")) %>%
      filter(!is.na(dist_bites)) -> sum_bites
  return(-sum(dpois(round(sum_bites$dist_bites), lambda = sum_bites$sum_bites, log = TRUE)))
}

tmp <- optim(par = c(1e-6, 1e-6, 0.1), get.likelihood, district = exps_dist,
             commune = comm_data, hessian = TRUE)
params <- tmp$par
B_ttimes <- params[1]
B_in <- params[2]
B_0 <- params[3]

comm_data %>%
      filter(exclude == 0) %>%
      group_by(mdg_dis_co) %>%
      mutate(bites = exp(B_ttimes*ttimes_weighted + B_in*ctar_in_comm + B_0)*pop) -> check
plot(check$ttimes_weighted, check$bites)

comm_data %>%
      filter(exclude == 0) %>%
      group_by(mdg_dis_co) %>%
      mutate(bites = exp(B_ttimes*ttimes_weighted + + B_in*ctar_in_comm + B_0)*pop) %>%
      summarize(sum_bites = sum(bites)) %>%
      left_join(select(exps_dist, district, dist_bites = bites), 
                by = c("mdg_dis_co" = "district")) %>%
      filter(!is.na(dist_bites)) -> sum_bites
sum_bites %$% plot(dist_bites, sum_bites)
abline(a = 0, b = 1, col = "blue", lty = 2)


```

### Model of proportion rabid

```{r Moramanga data}
## Libraries
library(ggThemeAssist)
library(colourpicker)
library(dplyr)
library(stringr)
library(lubridate)
library(ISOweek)
library(ggplot2)
library(knitr)
library(prettymapr)
# libraries for gis
library(raster)
library(maptools)
library(maps)
library(GISTools)
library(rgdal)
library(sp)
library(rgdal)
library(gdistance)

source("R/utils.R")

## data from WM
triage <- read.csv("data/moramanga/triage_up_todate.csv", header = TRUE)
ctar <- read.csv("data/moramanga/ctar_up_todate.csv", header = TRUE)
pep <- read.csv (paste0("data/WM/", list.files("data/WM/", pattern = "PEP")), header = TRUE)
hh <- read.csv (paste0("data/WM/", list.files("data/WM/", pattern = "Household")), header = TRUE)
human <- read.csv (paste0("data/WM/", list.files("data/WM/", pattern = "Human")), header = TRUE)
animal <- read.csv (paste0("data/WM/", list.files("data/WM/", pattern = "Animal")), header = TRUE)


## Read in new column names
col_lookup <- read.csv("data/new_colnames.csv", header = TRUE)
match.colnames <- function (dataframe, lookup){
  colnames(dataframe) <- lookup$new.colnames[match(colnames(dataframe), 
                                                   lookup$og.colnames)]
  dataframe <- dataframe[ , !names(dataframe) %in% c("NULL")]
  return(dataframe)
}

triage <- match.colnames(triage, subset(col_lookup, form == "triage"))
ctar <- match.colnames(ctar, subset(col_lookup, form == "ctar"))
pep <- match.colnames(pep, subset(col_lookup, form == "pep"))
hh <- match.colnames(hh, subset(col_lookup, form == "hh"))
animal <- match.colnames(animal, subset(col_lookup, form == "animal"))
human <- match.colnames(human, subset(col_lookup, form == "human"))

# fix factor names
match.within <- function (vec_return, mismatch, match){
  for (i in 1:length(match)){
    if (is.na(mismatch[i])) next
    mismatched <- paste0 ("\\<", mismatch[i], "\\>")
    vec_return <- gsub(mismatched, match[i], vec_return, ignore.case = TRUE)
  }
  return (vec_return)
}

## Changing suspected to probable
animal$suspect.animal <- match.within(animal$suspect.animal, "Suspected", "Probable")
human$suspect.exposure <- match.within(human$suspect.exposure, "Suspected", "Probable")
triage$suspect.animal <- match.within(triage$suspect.animal, "Suspected", "Probable")

## get number of animals + humans bitten by biter.IDs here!
animals.bitten.byID <- table(animal$biter.ID)
humans.bitten.byID <- table(human$biter.ID)

## Set-up time series plotting (axes)
tfunc <- function (date, format_date="%Y-%m-%d", start="01-09-2016", format_start="%d-%m-%Y",
                   year1=2016, tstep="month", period=FALSE) {
  get.consec (date, format_date, start, format_start,
              year1, tstep, period) - 8
}

## all dates
triage %>% 
  mutate_at(vars(starts_with("date")), funs(dmy(.))) -> triage
pep$pep.date <- dmy(pep$pep.date)
ctar %>%
  mutate_at(vars(starts_with("date")), funs(dmy(.))) -> ctar
animal %>%
  mutate_at(vars(starts_with("date")), funs(dmy(.))) -> animal
human %>%
  mutate_at(vars(starts_with("date")), funs(dmy(.))) -> human

# triage
triage$commune <- sapply(strsplit(as.character(triage$exposure.location), "\\("), "[", 1)
triage$commune <- trimws(triage$commune, which = "right")
triage$district <- sapply(strsplit(as.character(triage$exposure.location), "\\, "), "[", 2)
triage$district <- gsub(" \\(District\\)", "", triage$district)

# ctar
ctar$commune <- sapply(strsplit(as.character(ctar$patient.location), "\\("), "[", 1)
ctar$commune <- trimws(ctar$commune, which = "right")
ctar$district <- sapply(strsplit(as.character(ctar$patient.location), "\\, "), "[", 2)
ctar$district <- gsub(" \\(District\\)", "", ctar$district)

## animal and human locations
animal <- merge(animal, hh, by = "reference.hh")
human <- merge(human, hh, by = "reference.hh")

## get apprx case dates
ctar$ctar.ID <- paste0(ctar$ctar.ID, "_", year(ctar$date.reported))
human$ctar.ID <- paste0(human$ctar.ID, "_", year(human$date.bitten))
human$reference.ctar <- ctar$reference.ctar[match(human$ctar.ID, ctar$ctar.ID)]
#human$date.bitten[!is.na(human$reference.ctar)] <- ctar$date.bitten[match(human$reference.ctar[!is.na(human$reference.ctar)], ctar$reference.ctar)]

human %>%
  group_by(biter.ID) %>% 
  summarise(sort(date.bitten)[1]) -> date.first.bite
animal$date.case <- date.first.bite$`sort(date.bitten)[1]`[match(animal$ID, date.first.bite$biter.ID)]
animal$date.case[is.na(animal$date.case)] <- animal$date.first.bite[is.na(animal$date.case)]
animal$date.case[is.na(animal$date.case)] <- animal$date.symptoms.started[is.na(animal$date.case)] # fixing animals which don't have a case date (i.e. non-biters, but ones that are still suspect!)
## what about ones without a date?? recheck!

ctar %>%
  group_by(reference.triage) %>% 
  summarise(sort(date.bitten)[1]) -> date.first.bite
triage$date.case <- date.first.bite$`sort(date.bitten)[1]`[match(triage$reference.triage, date.first.bite$reference.triage)]
triage$date.case[is.na(triage$date.case)] <-triage$date.reported[is.na(triage$date.case)]

## get all months 
triage$month <- tfunc(triage$date.reported)
ctar$month <- tfunc(ctar$date.reported)
human$month <- tfunc(human$date.bitten)
animal$month <- tfunc(animal$date.case)
pep$month <- tfunc(pep$pep.date)

## change all true/false to 0/1
triage[triage == FALSE] <- 0
ctar[ctar == FALSE] <- 0
animal[animal == FALSE] <- 0
human[human == FALSE] <- 0
pep[pep == FALSE] <- 0
pep[pep == TRUE] <- 1

## subset to study period (Sep 2016 - to date)
## checks for cases where month is NA!
triage <- subset(triage, month > 0 & month < 25)
ctar <- subset(ctar, month > 0 & month < 25)
human <- subset(human, month > 0 & month < 25)
animal <- subset(animal, month > 0 & month < 25)
pep <- subset(pep, month > 0 & month < 25)

## linking up
ctar$traced <- NA
ctar$traced <- match(ctar$ctar.ID, human$ctar.ID)
ctar$traced[ctar$traced > 0] <- 1
ctar$traced[is.na(ctar$traced)] <- 0
ctar$reference.human <- human$reference.human[match(ctar$ctar.ID, human$ctar.ID)]
triage$reference.human <- ctar$reference.human[match(triage$reference.triage, ctar$reference.triage)] ## here!
triage$suspect.animal[!is.na(triage$reference.human)] <- human$suspect.exposure[match(triage$reference.human[!is.na(triage$reference.human)], human$reference.human)]

ctar$suspect.exposure <- triage$suspect.animal[match(ctar$reference.triage, triage$reference.triage)] ## matched to triage!

nonbites <- c("CTAR_201708_000016", "CTAR_201708_000017", "CTAR_201708_000001", "CTAR_201708_000002",
              "CTAR_201708_000003", "CTAR_201709_000037")
ctar$traced[ctar$reference.ctar %in% nonbites] <- 1
triage <- triage[which(triage$reference.triage %in% ctar$reference.triage), ] ## only triage with corresponding exposures
ctar <- ctar[which(ctar$reference.triage %in% triage$reference.triage), ] ## only ctar with corresponding exposures

## triage data
triage$triaged <- NA
triage$triaged[triage$triage.status == "Successful"] <- 1
triage$triaged[is.na(triage$triaged)] <- 0
triage$traced <- ctar$traced[match(triage$reference.triage, ctar$reference.triage)]
triage$traced[which(triage$reference.triage %in% ctar$reference.triage[ctar$traced == 1])] <- 1
triage$traced[is.na(triage$traced)] <- 0
nonlinked <- c("TR_201709_000014", "TR_201802_001040", "TR_201802_001045", "TR_201802_001063",  "TR_201802_001107", "TR_201802_001219", "TR_201802_001253", "TR_201802_001332", "TR_201802_001361", "TR_201802_001372", "TR_201709_000031", "TR_201708_000042", "TR_201708_000010", "TR_201708_000001", "TR_201709_000020", "TR_201709_000019", "TR_201709_000035", "TR_201709_000023", "TR_201709_000027", "TR_201710_000025", "TR_201711_000008", "TR_201712_000020", "TR_201712_000027", "TR_201708_000002")
triage$traced[triage$reference.triage %in% nonlinked] <- 1
triage$followedup <- triage$traced + triage$triaged
triage$followedup[triage$followedup > 1] <- 1

## cleaning up statuses
ctar$suspect.exposure <- as.factor(ctar$suspect.exposure)
triage$suspect.animal <- as.factor(triage$suspect.animal)
levels(ctar$suspect.exposure) <- c(levels(ctar$suspect.exposure), "Contact with suspect case")
ctar$suspect.exposure[ctar$consult.type == "Contact with suspect case"] <- "Contact with suspect case"
levels(ctar$suspect.exposure)[levels(ctar$suspect.exposure) == ""] <- "Unknown"
levels(triage$suspect.animal)[levels(triage$suspect.animal) == ""] <- "Unknown"
ctar$followedup <- triage$followedup[match(ctar$reference.triage, triage$reference.triage)]

## folks that reported after tracing
ctar$date.traced <- human$date.traced[match(ctar$ctar.ID, human$ctar.ID)]
date.diff <- ctar$date.traced - ctar$date.reported
date.diff[is.na(date.diff)] <-0
after.tracing <- ctar[date.diff < 0,]
ctar <- ctar[date.diff >= 0, ]
nrow(after.tracing)

ctar$triaged <- triage$triaged[match(ctar$reference.triage, triage$reference.triage)]
ctar %>%
  left_join(select(mada_communes@data, commune, mdg_cm_, mtch_ds), 
                          by = c("commune" = "commune", "district" = "mtch_ds")) %>%
  filter(triaged == 1, consult.type != "Contact with suspect case") %>%
  dplyr::select(mdg_cm_, suspect.exposure) %>%
  gather(suspect.exposure, value, -mdg_cm_) %>%
  group_by(mdg_cm_, value) %>%
  tally %>%
  spread(value, n, fill = 0) %>%
  mutate(total = Confirmed + No + Probable + Unknown, 
         rabid_upper = Confirmed + Probable + Unknown,
         rabid_lower = Confirmed + Probable) %>% 
  left_join(comm_covars) %>%
  filter(!is.na(ttimes_weighted), district != "Antananarivo Renivohitra") -> prop_rabid

## Model of proportion rabid
prop_rabid %$% plot(ttimes_weighted, rabid_lower/total)
mod <- glm(cbind(rabid_lower, total - rabid_lower) ~ ttimes_weighted, data = prop_rabid, 
           family = binomial)
prop_rabid %$% plot(rabid_lower/total, predict(mod, type = "response"))
prop_rabid %$% plot(ttimes_weighted, predict(mod, type = "response"), ylim = c(0, 1))
prop_rabid %$% points(ttimes_weighted, rabid_lower/total, col = "blue")

mod <- glm(cbind(rabid_upper, total - rabid_upper) ~ ttimes_weighted, data = prop_rabid, 
           family = binomial)
prop_rabid %$% plot(rabid_upper/total, predict(mod, type = "response"))
prop_rabid %$% plot(ttimes_weighted, predict(mod, type = "response"), ylim = c(0, 1))
prop_rabid %$% points(ttimes_weighted, rabid_upper/total, col = "blue")

```


```{r likelihood of observing moramanga data @ commune level}
## Bite data in Moramanga
ctar %>%
  left_join(select(mada_communes@data, commune, mdg_cm_, mtch_ds), 
                          by = c("commune" = "commune", "district" = "mtch_ds")) %>%
  filter(consult.type == "Animal bite/exposure") %>%
  group_by(mdg_cm_) %>%
  summarize(bites = n()) %>%
  left_join(comm_covars) %>%
  filter(!is.na(ttimes_weighted), district %in% c("Moramanga", "Anosibe-An'ala")) -> bites

get.likelihood <- function(commune, params) {
  # To test likelihood function
  # commune = comm_data
  # district = exps_dist
  # params = c(1e-6, 0.1)
  B_ttimes <- params[1]
  B_0 <- params[2]
  commune %>%
      mutate(bites_mu = exp(B_ttimes*ttimes_weighted + B_0)*pop) -> sum_bites
  return(-sum(dpois(round(sum_bites$bites), lambda = sum_bites$bites_mu, log = TRUE)))
}

tmp <- optim(par = c(1e-6, 0.1), get.likelihood, commune = bites, hessian = TRUE)
params <- tmp$par
B_ttimes <- params[1]
B_0 <- params[2]

## Getting standard errors
# this is how you can get standard errors from optim, but inverting the hessian
se <- sqrt(abs(diag(solve(tmp$hessian)))); se

ex#simulate "standard errors"
varcov <- solve(tmp$hessian)
library(MASS)

ntest = 1000; testpar = tmp$par; sim.par = matrix(NA, ntest, 2)
for (k in 1:ntest) {
  sim.par[k, ] = mvrnorm(1, tmp$par, varcov)
}

mean(tmp$par[1])
mean(tmp$par[2])
#exp(mean(tmp$par[4]))

quantile(sim.par[,1],c(0.025,0.975))
quantile(sim.par[,2],c(0.025,0.975))

bites %>%
      mutate(bites_mu = exp(B_ttimes*ttimes_weighted + B_0)*pop) -> check
plot(check$ttimes_weighted, check$bites)
plot(check$bites, check$bites_mu)
abline(a = 0, b = 1, col = "blue", lty = 2)
ttimes_run <- seq(0, 12*60, by = 30)
test_pop = 1e5
plot(ttimes_run, exp(B_ttimes*ttimes_run + B_0)*test_pop, type = "l")
     
```

### Estimation of burden and reporting 

```{r functions for getting burden}
get.burden <- function(covs = covars, pop = covars$pop, model = mod,
                       p_rabid = 0.5, rho_max = 0.9,
                       max_HDR = 25, min_HDR = 5, 
                       dog_rabies_inc = 0.01, human_exp_rate = 0.39, 
                       prob_death = 0.16, nsims = 1000) {
  store_deaths <- store_p_rabid <- matrix(NA, nrow(covs), nsims)

  for (i in 1:nsims) {
    mean_bites <- predict(model, type = "response", newdata = covs)
    bites <- rpois(length(mean_bites), mean_bites)
    mean_exps <- runif(length(pop), min = human_exp_rate*dog_rabies_inc*pop/max_HDR, 
                    max = human_exp_rate*dog_rabies_inc*pop/min_HDR)
    rabid_exps <- rpois(length(mean_bites), mean_exps)
    p_rabid_t <- ifelse(bites*p_rabid/rabid_exps > rho_max, (rho_max*rabid_exps)/bites, p_rabid)
    deaths <- rbinom(length(mean_bites), rabid_exps - round(bites*p_rabid_t), prob_death)
    store_deaths[, i] <- deaths
    store_p_rabid[, i] <- p_rabid_t
  }
  
  results <- cbind(get.meanCI(store_deaths), get.meanCI(store_p_rabid))
  colnames(results) <- c("deaths_mean", "deaths_lowerCI", "deaths_upperCI",
                         "p_rabid_mean", "p_rabid_lowerCI", "p_rabid_upperCI")
  results <- cbind(covars, results)
  return(results)
}

get.burden.flat <- function(covs = covars, pop = covars$pop, model = mod,
                       p_rabid = 0.5, rho = 0.85, 
                       prob_death = 0.16, nsims = 1000) {
  store_deaths <- matrix(NA, nrow(covs), nsims)

  for (i in 1:nsims) {
    mean_bites <- predict(model, type = "response", newdata = covs)
    bites <- rpois(length(mean_bites), mean_bites)
    unreported <- bites*p_rabid/rho - bites*p_rabid
    deaths <- rbinom(length(mean_bites), round(unreported), prob_death)
    store_deaths[, i] <- deaths
  }
  results <- get.meanCI(store_deaths)
  colnames(results) <- c("deaths_mean", "death_lowerCI", "deaths_upperCI")
  results <- cbind(covars, results)
  return(results)
}

get.meanCI <- function(matrix_by_row, nboots = 1000) {
    mean_rows <- apply(matrix_by_row, 1, mean)
    CIs <- apply(matrix_by_row, 1, boots, nboot = nboots)
    lower <- unlist(CIs)[1, ] 
    upper <- unlist(CIs)[2, ]
    summ <- cbind(mean_rows, lower, upper)
    colnames(summ) <- c("mean", "lower", "upper")
    return(summ)
}

boots <- function(x, nboot = 1000){
  n = length(x)
  xbar = mean(x)
  tmpdata = sample(x,n*nboot, replace=TRUE)
  bootstrapsample = matrix(tmpdata, nrow=n, ncol=nboot)
  bsmeans = colMeans(bootstrapsample)
  deltastar = bsmeans - xbar
  d = quantile(deltastar, c(0.05, 0.95))
  ## Get from quantiles
  ci = xbar - c(d[2], d[1])

  ## Sorted CIs
  sorteddeltastar = sort(deltastar)
  # # Look at the sorted results
  # Find the .05 and .95 critical values of deltastar
  d9alt = sorteddeltastar[5]
  d1alt = sorteddeltastar[950]
  # Find and print the 80% confidence interval for the mean
  ciAlt = xbar - c(d1alt,d9alt)
  # cat(’Alternative confidence interval: ’,ciAlt, ’\n’)
  return(ci)
}

```

```{r}
results_pr20 <- get.burden(p_rabid = 0.20, rho_max = 0.98)
results_pr60 <- get.burden(p_rabid = 0.60,rho_max = 0.98)

plot(results_pr20$ttimes_weighted/60, results_pr20$deaths_mean, col = "darkred", pch = 20)
points(results_pr60$ttimes_weighted/60, results_pr60$deaths_mean, col = "red", pch = 20)
segments(x0 = results_pr60$ttimes_weighted/60, x1 = results_pr60$ttimes_weighted/60,
         y0 = results_pr60$deaths_mean, y1 = results_pr20$deaths_mean, col = "red")

results_base <- get.burden(p_rabid = 0.40, rho_max = 0.98)

p_rabid_check <- seq(0.10, 0.80, by = 0.1)
check <- data.frame(p_rabid = 0, district = NA, ttimes = 0, deaths_mean = 0)
for (i in 1:length(p_rabid_check)) {
  print(paste(i, "/", length(p_rabid_check)))
  results <- get.burden(p_rabid = p_rabid_check[i], rho_max = 0.98)
  p_rabid <- rep(p_rabid_check[i], length(results$deaths_mean))
  check_one <- cbind(p_rabid, results$district, results$ttimes, results$deaths_mean)
  colnames(check_one) <- c("p_rabid", "district", "ttimes", "deaths_mean")
  check <- rbind(check, check_one)
}

check <- check[-1, ]
check$base <- rep(results_base$deaths_mean, length(p_rabid_check))
ggplot(data = check, aes(x = as.factor(p_rabid), y = as.factor(reorder(district, ttimes)))) + 
  geom_tile(aes(fill = deaths_mean/base)) +
  scale_fill_gradient2(high = "red", mid = "white", low = "blue", midpoint = 1, name = "Mean deaths") 

rho_max_check <- seq(0.90, 0.99, by = 0.01)
check <- data.frame(rho_max = 0, district = NA, ttimes = 0, deaths_mean = 0)
for (i in 1:length(rho_max_check)) {
  print(paste(i, "/", length(rho_max_check)))
  results <- get.burden(p_rabid = 0.4, rho_max = rho_max_check[i])
  rho_max <- rep(rho_max_check[i], length(results$deaths_mean))
  check_one <- cbind(rho_max, results$district, results$ttimes, results$deaths_mean)
  colnames(check_one) <- c("rho_max", "district", "ttimes", "deaths_mean")
  check <- rbind(check, check_one)
}

check <- check[-1, ]
check$base <- rep(results_base$deaths_mean, length(rho_max_check))
check %>%
  group_by(district) %>%
  mutate(min = min(deaths_mean), max = max(deaths_mean), 
         standardized = (deaths_mean - base)/(max - base)) -> check

ggplot(data = check, aes(x = as.factor(p_rabid), y = as.factor(reorder(district, ttimes)))) + 
  geom_tile(aes(fill = standardized)) +
  scale_fill_gradient2(high = "red", mid = "white", low = "blue", midpoint = 0, name = "Mean deaths") 
ggplot(data = check, aes(x = as.factor(p_rabid), y = as.factor(reorder(district, ttimes)))) + 
  geom_tile(aes(fill = deaths_mean)) +
  scale_fill_gradient2(high = "red", mid = "white", low = "blue", midpoint = 0, name = "Mean deaths") 

mada_dist_gg <- tidy(mada_district, region = "mdg_dis_co")
mada_dist_gg <- left_join(mada_dist_gg, exps_cleaned, by = c("id" = "district"))

ggplot() +
  geom_polygon(data = mada_dist_gg, aes(x = long, y = lat, group = group, fill = CTAR)) +
  scale_colour_viridis_d()

```

### Sensitivity Analyses

### Estimating the impact of expanding PEP Access

## Discussion

### Key findings

### Strengths and Limitations
- Not accounting for clinic functioning
- Not explicit data on reporting or rabies incidence!
- Other factors that drive reporting

### Broader context

### Conclusions
